diff -Naur a/scribus/plugins/import/pdf/importpdfconfig.h b/scribus/plugins/import/pdf/importpdfconfig.h
--- a/scribus/plugins/import/pdf/importpdfconfig.h	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/importpdfconfig.h	2022-10-06 13:58:35.961648039 +0200
@@ -15,53 +15,4 @@
 	+ ((micro) *     1))
 #define POPPLER_ENCODED_VERSION POPPLER_VERSION_ENCODE(POPPLER_VERSION_MAJOR, POPPLER_VERSION_MINOR, POPPLER_VERSION_MICRO)
 
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 64, 0)
-#define POPPLER_CONST const
-#else
-#define POPPLER_CONST
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 70, 0)
-#define POPPLER_CONST_070 const
-#else
-#define POPPLER_CONST_070
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 71, 0)
-#define GBool  bool
-#define gTrue  true
-#define gFalse false
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 72, 0)
-#define getCString  c_str
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 73, 0)
-#define Guchar  unsigned char
-#define Gushort unsigned short
-#define Guint   unsigned int
-#define Gulong  unsigned long
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 75, 0)
-#define POPPLER_CONST_075 const
-#define POPPLER_REF &
-#else
-#define POPPLER_CONST_075
-#define POPPLER_REF
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 82, 0)
-#define POPPLER_CONST_082 const
-#else
-#define POPPLER_CONST_082
-#endif
-
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 83, 0)
-#define POPPLER_CONST_083 const
-#else
-#define POPPLER_CONST_083
-#endif
-
 #endif
diff -Naur a/scribus/plugins/import/pdf/importpdf.cpp b/scribus/plugins/import/pdf/importpdf.cpp
--- a/scribus/plugins/import/pdf/importpdf.cpp	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/importpdf.cpp	2022-10-06 13:58:35.961648039 +0200
@@ -16,7 +16,6 @@
 #include <QInputDialog>
 #include <QList>
 #include <QMimeData>
-#include <QRegExp>
 #include <QStack>
 
 #include <poppler/ErrorCodes.h>
@@ -36,33 +35,19 @@
 
 #include "commonstrings.h"
 #include "loadsaveplugin.h"
-#include "pagesize.h"
 #include "pdfimportoptions.h"
 #include "pdfoptions.h"
-#include "prefscontext.h"
-#include "prefsfile.h"
 #include "prefsmanager.h"
-#include "prefstable.h"
-#include "rawimage.h"
-#include "scclocale.h"
-#include "sccolorengine.h"
 #include "scconfig.h"
 #include "scmimedata.h"
-#include "scpaths.h"
 #include "scribus.h"
 #include "scribusXml.h"
 #include "scribuscore.h"
-#include "sctextstream.h"
 #include "selection.h"
 #include "undomanager.h"
 #include "util.h"
-#include "util_formats.h"
-#include "util_math.h"
-
-#include "ui/customfdialog.h"
-#include "ui/missing.h"
+#include "util_os.h"
 #include "ui/multiprogressdialog.h"
-#include "ui/propertiespalette.h"
 
 PdfPlug::PdfPlug(ScribusDoc* doc, int flags)
 {
@@ -75,22 +60,18 @@
 
 QImage PdfPlug::readThumbnail(const QString& fName)
 {
-	QString pdfFile = QDir::toNativeSeparators(fName);
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 83, 0)
 	globalParams.reset(new GlobalParams());
-#else
-	std::unique_ptr<GlobalParams> globalParamsPtr(new GlobalParams());
-	globalParams = globalParamsPtr.get();
-#endif
+	globalParams->setErrQuiet(true);
 
-#if defined(Q_OS_WIN32) && POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 62, 0)
-	auto fname = new GooString(pdfFile.toUtf8().data());
+	QString pdfFile = QDir::toNativeSeparators(fName);
+	QByteArray encodedFileName = os_is_win() ? pdfFile.toUtf8() : QFile::encodeName(pdfFile);
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 3, 0)
+	auto fname = std::make_unique<GooString>(encodedFileName.data());
+	PDFDoc pdfDoc{ std::move(fname) };
 #else
-	auto fname = new GooString(QFile::encodeName(pdfFile).data());
-#endif
-	globalParams->setErrQuiet(gTrue);
-
+	auto fname = new GooString(encodedFileName.data());
 	PDFDoc pdfDoc{fname, nullptr, nullptr, nullptr};
+#endif
 	if (!pdfDoc.isOk() || pdfDoc.getErrorCode() == errEncrypted)
 		return QImage();
 
@@ -103,11 +84,11 @@
 	bgColor[0] = 255;
 	bgColor[1] = 255;
 	bgColor[2] = 255;
-	SplashOutputDev dev(splashModeXBGR8, 4, gFalse, bgColor, gTrue);
-	dev.setVectorAntialias(gTrue);
-	dev.setFreeTypeHinting(gTrue, gFalse);
+	SplashOutputDev dev(splashModeXBGR8, 4, false, bgColor, true);
+	dev.setVectorAntialias(true);
+	dev.setFreeTypeHinting(true, false);
 	dev.startDoc(&pdfDoc);
-	pdfDoc.displayPage(&dev, 1, hDPI, vDPI, 0, gTrue, gFalse, gFalse);
+	pdfDoc.displayPage(&dev, 1, hDPI, vDPI, 0, true, false, false);
 	SplashBitmap *bitmap = dev.getBitmap();
 	int bw = bitmap->getWidth();
 	int bh = bitmap->getHeight();
@@ -145,7 +126,7 @@
 	m_importerFlags = flags;
 	m_cancel = false;
 	bool ret = false;
-	QFileInfo fi = QFileInfo(fNameIn);
+	QFileInfo fi(fNameIn);
 	if ( !ScCore->usingGUI() )
 	{
 		m_interactive = false;
@@ -318,7 +299,6 @@
 bool PdfPlug::convert(const QString& fn)
 {
 	bool firstPg = true;
-	int currentLayer = m_Doc->activeLayer();
 	int baseLayer = m_Doc->activeLayer();
 	m_importedColors.clear();
 	if (m_progressDialog)
@@ -329,21 +309,18 @@
 		qApp->processEvents();
 	}
 
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 83, 0)
 	globalParams.reset(new GlobalParams());
+	globalParams->setErrQuiet(true);
+
+	QList<OptionalContentGroup*> ocgGroups;
+	QByteArray encodedFileName = os_is_win() ? fn.toUtf8() : QFile::encodeName(fn);
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 3, 0)
+	auto fname = std::make_unique<GooString>(encodedFileName.data());
+	auto pdfDoc = std::make_unique<PDFDoc>(std::move(fname));
 #else
-	std::unique_ptr<GlobalParams> globalParamsPtr(new GlobalParams());
-	globalParams = globalParamsPtr.get();
-#endif
-#if defined(Q_OS_WIN32) && POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 62, 0)
-	auto fname = new GooString(fn.toUtf8().data());
-#else
-	auto fname = new GooString(QFile::encodeName(fn).data());
+	auto fname = new GooString(encodedFileName.data());
+	auto pdfDoc = std::make_unique<PDFDoc>(fname, nullptr, nullptr, nullptr);
 #endif
-	globalParams->setErrQuiet(gTrue);
-//	globalParams->setPrintCommands(gTrue);
-	QList<OptionalContentGroup*> ocgGroups;
-	auto pdfDoc = std::unique_ptr<PDFDoc>(new PDFDoc(fname, nullptr, nullptr, nullptr));
 	if (pdfDoc)
 	{
 		if (pdfDoc->getErrorCode() == errEncrypted)
@@ -357,22 +334,21 @@
 			QString text = QInputDialog::getText(mw, tr("Open PDF-File"), tr("Password"), QLineEdit::Normal, "", &ok);
 			if (ok && !text.isEmpty())
 			{
-#if defined(Q_OS_WIN32) && POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 62, 0)
-				auto fname = new GooString(fn.toUtf8().data());
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 3, 0)
+				auto fname = std::make_unique<GooString>(encodedFileName.data());
+				std::optional<GooString> userPW(std::in_place, text.toLocal8Bit().data());
+				pdfDoc.reset(new PDFDoc(std::move(fname), userPW, userPW, nullptr));
 #else
-				auto fname = new GooString(QFile::encodeName(fn).data());
-#endif
+				auto fname = new GooString(encodedFileName.data());
 				auto userPW = new GooString(text.toLocal8Bit().data());
 				pdfDoc.reset(new PDFDoc(fname, userPW, userPW, nullptr));
+#endif
 				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 			}
 			if ((!pdfDoc) || (pdfDoc->getErrorCode() != errNone))
 			{
 				if (m_progressDialog)
 					m_progressDialog->close();
-#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(0, 83, 0)
-				delete globalParams;
-#endif
 				return false;
 			}
 			if (m_progressDialog)
@@ -387,9 +363,9 @@
 			double vDPI = 72.0;
 			int firstPage = 1;
 			int lastPage = pdfDoc->getNumPages();
-			GBool useMediaBox = gTrue;
-			GBool crop = gTrue;
-			GBool printing = gFalse;
+			bool useMediaBox = true;
+			bool crop = true;
+			bool printing = false;
 			const PDFRectangle *mediaBox = pdfDoc->getPage(1)->getMediaBox();
 			QRectF mediaRect = QRectF(QPointF(mediaBox->x1, mediaBox->y1), QPointF(mediaBox->x2, mediaBox->y2)).normalized();
 			bool boxesAreDifferent = false;
@@ -410,7 +386,7 @@
 					m_progressDialog->hide();
 				qApp->changeOverrideCursor(QCursor(Qt::ArrowCursor));
 				PdfImportOptions optImp(ScCore->primaryMainWindow());
-				QFileInfo fi = QFileInfo(fn);
+				QFileInfo fi(fn);
 				optImp.setUpOptions(fi.fileName(), firstPage, lastPage, m_interactive, boxesAreDifferent, this);
 				if (!optImp.exec())
 				{
@@ -428,9 +404,9 @@
 				// When displaying	pages slices, we should always set useMediaBox to true
 				// in order to use MediaBox (x, y) as coordinate system
 				if (contentRect != Media_Box)
-					useMediaBox = gFalse;
+					useMediaBox = false;
 				if (cropped)
-					useMediaBox = gTrue;
+					useMediaBox = true;
 				qApp->changeOverrideCursor(QCursor(Qt::WaitCursor));
 				if (m_progressDialog)
 					m_progressDialog->show();
@@ -468,7 +444,7 @@
 							Object orderItem = order->get(i);
 							if (orderItem.isDict())
 							{
-								POPPLER_CONST_075 Object POPPLER_REF ref = order->getNF(i);
+								const Object & ref = order->getNF(i);
 								if (ref.isRef())
 								{
 									OptionalContentGroup *oc = ocg->findOcgByRef(ref.getRef());
@@ -482,7 +458,6 @@
 							}
 							else
 							{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 69, 0)
 								const auto& ocgs = ocg->getOCGs ();
 								for (const auto& ocg : ocgs)
 								{
@@ -494,25 +469,11 @@
 										ocgNames.append(ocgName);
 									}
 								}
-#else
-								GooList *ocgs = ocg->getOCGs ();
-								for (int i = 0; i < ocgs->getLength (); ++i)
-								{
-									OptionalContentGroup *oc = (OptionalContentGroup *)ocgs->get(i);
-									QString ocgName = UnicodeParsedString(oc->getName());
-									if (!ocgNames.contains(ocgName))
-									{
-										ocgGroups.prepend(oc);
-										ocgNames.append(ocgName);
-									}
-								}
-#endif
 							}
 						}
 					}
 					else
 					{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 69, 0)
 						const auto& ocgs = ocg->getOCGs ();
 						for (const auto& ocg : ocgs)
 						{
@@ -524,19 +485,6 @@
 								ocgNames.append(ocgName);
 							}
 						}
-#else
-						GooList *ocgs = ocg->getOCGs ();
-						for (int i = 0; i < ocgs->getLength (); ++i)
-						{
-							OptionalContentGroup *oc = (OptionalContentGroup *)ocgs->get(i);
-							QString ocgName = UnicodeParsedString(oc->getName());
-							if (!ocgNames.contains(ocgName))
-							{
-								ocgGroups.prepend(oc);
-								ocgNames.append(ocgName);
-							}
-						}
-#endif
 					}
 				}
 
@@ -550,6 +498,7 @@
 					if (ocg && ocg->hasOCGs())
 					{
 						QString actL(m_Doc->activeLayerName());
+						int currentLayer;
 						for (int i = 0; i < ocgGroups.count(); i++)
 						{
 							OptionalContentGroup *oc = ocgGroups[i];
@@ -775,13 +724,8 @@
 							names = catDict.dictLookup("OpenAction");
 							if (names.isDict())
 							{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 								std::unique_ptr<LinkAction> linkActionUPtr = LinkAction::parseAction(&names, pdfDoc->getCatalog()->getBaseURI());
 								LinkAction *linkAction = linkActionUPtr.get();
-#else
-								LinkAction *linkAction = nullptr;
-								linkAction = LinkAction::parseAction(&names, pdfDoc->getCatalog()->getBaseURI());
-#endif
 								if (linkAction && (linkAction->getKind() == actionJavaScript))
 								{
 									LinkJavaScript *jsa = (LinkJavaScript*) linkAction;
@@ -849,11 +793,7 @@
 		}
 		pdfDoc.reset();
 	}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 83, 0)
 	globalParams.reset();
-#else
-	globalParams = nullptr;
-#endif
 
 //	qDebug() << "converting finished";
 //	qDebug() << "Imported" << m_elements.count() << "Elements";
@@ -885,11 +825,11 @@
 	bgColor[0] = 255;
 	bgColor[1] = 255;
 	bgColor[2] = 255;
-	SplashOutputDev *dev = new SplashOutputDev(splashModeXBGR8, 4, gFalse, bgColor, gTrue);
-	dev->setVectorAntialias(gTrue);
-	dev->setFreeTypeHinting(gTrue, gFalse);
+	SplashOutputDev *dev = new SplashOutputDev(splashModeXBGR8, 4, false, bgColor, true);
+	dev->setVectorAntialias(true);
+	dev->setFreeTypeHinting(true, false);
 	dev->startDoc(m_pdfDoc);
-	m_pdfDoc->displayPage(dev, pgNum, hDPI, vDPI, 0, gTrue, gFalse, gFalse);
+	m_pdfDoc->displayPage(dev, pgNum, hDPI, vDPI, 0, true, false, false);
 	SplashBitmap *bitmap = dev->getBitmap();
 	int bw = bitmap->getWidth();
 	int bh = bitmap->getHeight();
@@ -948,23 +888,23 @@
 	return cRect;
 }
 
-QString PdfPlug::UnicodeParsedString(POPPLER_CONST GooString *s1)
+QString PdfPlug::UnicodeParsedString(const GooString *s1)
 {
 	if ( !s1 || s1->getLength() == 0 )
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	int i;
 	Unicode u;
 	QString result;
 	if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getLength() > 1 && (s1->getChar(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1->getLength() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1->getLength());
 	}
@@ -992,19 +932,19 @@
 {
 	if (s1.length() == 0)
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	size_t i;
 	Unicode u;
 	QString result;
 	if ((s1.at(0) & 0xff) == 0xfe && (s1.length() > 1 && (s1.at(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1.length() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1.length());
 	}
diff -Naur a/scribus/plugins/import/pdf/importpdf.h b/scribus/plugins/import/pdf/importpdf.h
--- a/scribus/plugins/import/pdf/importpdf.h	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/importpdf.h	2022-10-06 13:58:35.961648039 +0200
@@ -81,7 +81,7 @@
 private:
 	bool convert(const QString& fn);
 	QRectF getCBox(int box, int pgNum);
-	QString UnicodeParsedString(POPPLER_CONST GooString *s1);
+	QString UnicodeParsedString(const GooString *s1);
 	QString UnicodeParsedString(const std::string& s1);
 	
 	QList<PageItem*> m_elements;
diff -Naur a/scribus/plugins/import/pdf/importpdfplugin.cpp b/scribus/plugins/import/pdf/importpdfplugin.cpp
--- a/scribus/plugins/import/pdf/importpdfplugin.cpp	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/importpdfplugin.cpp	2022-10-06 13:58:35.961648039 +0200
@@ -193,7 +193,7 @@
 		activeTransaction = UndoManager::instance()->beginTransaction(trSettings);
 
 	bool isCleanedFile = false;
-	QString cleanFile = "";
+	QString cleanFile;
 	if (exts.contains(fi.suffix().toLower()))
 	{
 		if (!ScCore->haveGS())
diff -Naur a/scribus/plugins/import/pdf/pdftextrecognition.cpp b/scribus/plugins/import/pdf/pdftextrecognition.cpp
--- a/scribus/plugins/import/pdf/pdftextrecognition.cpp	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/pdftextrecognition.cpp	2022-10-06 13:58:35.965648052 +0200
@@ -39,7 +39,7 @@
 /*
 *	function called via integration with poppler's addChar callback. It decides how to add the charter based on the mode that is set
 */
-void PdfTextRecognition::addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen)
+void PdfTextRecognition::addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, const Unicode* u, int uLen)
 {
 
 	switch (this->m_addCharMode)
@@ -413,7 +413,7 @@
 void PdfTextRegion::renderToTextFrame(PageItem* textNode)
 {
 	textNode->setWidthHeight(this->maxWidth, this->maxHeight);
-	QString bodyText = "";
+	QString bodyText;
 	for (int glyphIndex = this->pdfTextRegionLines.begin()->glyphIndex; glyphIndex <= this->pdfTextRegionLines.back().segments.back().glyphIndex; glyphIndex++)
 		bodyText += glyphs[glyphIndex].code;
 
@@ -536,7 +536,7 @@
 	textNode->setFillColor(CommonStrings::None);
 	textNode->setLineColor(CommonStrings::None);
 	textNode->setLineWidth(0.0);
-	textNode->setFillShade(m_currFillShade);
+	textNode->setFillShade(m_graphicStack.top().fillShade);
 
 
 	/* Oliver Stieber 2020-06-11 Set text matrix... This need to be done so that the global world view that we rite out glyphs to is transformed correctly by the context matrix for each glyph, possibly anyhow.
@@ -567,7 +567,6 @@
 	*	This code can be used to set PoLine instead of setting the FrameShape if setting the PoLine is the more correct way of doing things.
 	*	I have no idea of what the PoLine is at this time except for it changes when the shape is set and appears to be unit scales as opposed to percentage scaled
 	FPointArray boundingBoxShape;
-	boundingBoxShape.resize(0);
 	boundingBoxShape.svgInit();
 	//doubles to create a shape, it's 100% textframe width by 100% textframe height
 
@@ -607,7 +606,7 @@
 	item->OwnPage = m_doc->OnPage(item);
 }
 
-void PdfTextOutputDev::drawChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen)
+void PdfTextOutputDev::drawChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, const Unicode* u, int uLen)
 {
 	// TODO Implement the clipping operations. At least the characters are shown.
 	int textRenderingMode = state->getRender();
@@ -669,10 +668,10 @@
 * NOTE: Override these for now and do nothing so they don't get picked up and rendered as vectors by the base class,
 	though in the long run we may actually want that unless they can be implemented in a similar way to the text import getChar in which case overloading the makes perfect sense.
 */
-GBool PdfTextOutputDev::beginType3Char(GfxState* state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode* u, int uLen)
+bool PdfTextOutputDev::beginType3Char(GfxState* state, double x, double y, double dx, double dy, CharCode code, const Unicode* u, int uLen)
 {
 	//stub
-	return gTrue;
+	return true;
 }
 void  PdfTextOutputDev::endType3Char(GfxState* state)
 {
diff -Naur a/scribus/plugins/import/pdf/pdftextrecognition.h b/scribus/plugins/import/pdf/pdftextrecognition.h
--- a/scribus/plugins/import/pdf/pdftextrecognition.h	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/pdftextrecognition.h	2022-10-06 13:58:35.965648052 +0200
@@ -125,7 +125,7 @@
 	PdfTextRegion* activePdfTextRegion = nullptr; //faster and cleaner than calling back on the vector all the time.
 
 	void addPdfTextRegion();
-	void addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen);
+	void addChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, const Unicode* u, int uLen);
 	bool isNewLineOrRegion(QPointF newPosition);
 
 private:
@@ -150,8 +150,8 @@
 	//----- text drawing
 	void  beginTextObject(GfxState* state) override;
 	void  endTextObject(GfxState* state) override;
-	void  drawChar(GfxState* state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, POPPLER_CONST_082 Unicode* /*u*/, int /*uLen*/) override;
-	GBool beginType3Char(GfxState* /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode* /*u*/, int /*uLen*/) override;
+	void  drawChar(GfxState* state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, const Unicode* /*u*/, int /*uLen*/) override;
+	bool  beginType3Char(GfxState* /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, const Unicode* /*u*/, int /*uLen*/) override;
 	void  endType3Char(GfxState* /*state*/) override;
 	void  type3D0(GfxState* /*state*/, double /*wx*/, double /*wy*/) override;
 	void  type3D1(GfxState* /*state*/, double /*wx*/, double /*wy*/, double /*llx*/, double /*lly*/, double /*urx*/, double /*ury*/) override;
diff -Naur a/scribus/plugins/import/pdf/slaoutput.cpp b/scribus/plugins/import/pdf/slaoutput.cpp
--- a/scribus/plugins/import/pdf/slaoutput.cpp	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/slaoutput.cpp	2022-10-06 13:58:35.965648052 +0200
@@ -7,12 +7,19 @@
 
 #include "slaoutput.h"
 
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+#include <memory>
+#include <optional>
+#endif
+
 #include <poppler/GlobalParams.h>
 #include <poppler/poppler-config.h>
 #include <poppler/FileSpec.h>
 #include <poppler/fofi/FoFiTrueType.h>
+
 #include <QApplication>
 #include <QFile>
+
 #include "commonstrings.h"
 #include "loadsaveplugin.h"
 #include "sccolorengine.h"
@@ -89,7 +96,7 @@
 			{
 				if (obj3.isName())
 				{
-					POPPLER_CONST char *name = obj3.getName();
+					const char *name = obj3.getName();
 					if (!strcmp(name, "URL"))
 					{
 						Object obj2 = obj1.dictLookup("F");
@@ -164,17 +171,22 @@
 	currColorStroke = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &shade);
 }
 
-void AnoOutputDev::drawString(GfxState *state, POPPLER_CONST GooString *s)
+void AnoOutputDev::drawString(GfxState *state, const GooString *s)
 {
 	int shade = 100;
 	currColorText = getColor(state->getFillColorSpace(), state->getFillColor(), &shade);
 	fontSize = state->getFontSize();
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+	if (state->getFont() && state->getFont()->getName())
+		fontName = new GooString(state->getFont()->getName().value());
+#else
 	if (state->getFont())
 		fontName = state->getFont()->getName()->copy();
+#endif
 	itemText = s->copy();
 }
 
-QString AnoOutputDev::getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade)
+QString AnoOutputDev::getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade)
 {
 	QString fNam;
 	QString namPrefix = "FromPDF";
@@ -215,7 +227,7 @@
 	{
 		GfxSeparationColorSpace* sepColorSpace = (GfxSeparationColorSpace*)color_space;
 		GfxColorSpace* altColorSpace = sepColorSpace->getAlt();
-		QString name = QString(sepColorSpace->getName()->getCString());
+		QString name = QString(sepColorSpace->getName()->c_str());
 		bool isRegistrationColor = (name == "All");
 		if (isRegistrationColor)
 		{
@@ -281,19 +293,17 @@
 	m_Elements = Elements;
 	pushGroup();
 	m_importedColors = importedColors;
-	m_currColorStroke = "Black";
-	m_currColorFill = "Black";
-	tmpSel = new Selection(m_doc, false);
-	importerFlags = flags;
-	currentLayer = m_doc->activeLayer();
+	m_tmpSel = new Selection(m_doc, false);
+	m_importerFlags = flags;
+	m_currentLayer = m_doc->activeLayer();
 	layersSetByOCG = false;
 }
 
 SlaOutputDev::~SlaOutputDev()
 {
 	m_groupStack.clear();
-	tmpSel->clear();
-	delete tmpSel;
+	m_tmpSel->clear();
+	delete m_tmpSel;
 	delete m_fontEngine;
 }
 
@@ -304,12 +314,12 @@
 	Object obj;
 	Ref refa = ano->getRef();
 
-	obj = xref->fetch(refa.num, refa.gen);
+	obj = m_xref->fetch(refa.num, refa.gen);
 	if (obj.isDict())
 	{
 		Dict* adic = obj.getDict();
-		POPPLER_CONST_075 Object POPPLER_REF additionalActions = adic->lookupNF("A");
-		Object additionalActionsObject = additionalActions.fetch(pdfDoc->getXRef());
+		const Object & additionalActions = adic->lookupNF("A");
+		Object additionalActionsObject = additionalActions.fetch(m_pdfDoc->getXRef());
 		if (additionalActionsObject.isDict())
 		{
 			Object actionObject = additionalActionsObject.dictLookup("S");
@@ -327,38 +337,37 @@
 }
 
 /* Replacement for the crippled Poppler function LinkAction* AnnotWidget::getAdditionalAction(AdditionalActionsType type) */
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 std::unique_ptr<LinkAction> SlaOutputDev::SC_getAdditionalAction(const char *key, AnnotWidget *ano)
 {
 	std::unique_ptr<LinkAction> linkAction;
-#else
-LinkAction* SlaOutputDev::SC_getAdditionalAction(const char *key, AnnotWidget *ano)
-{
-	LinkAction *linkAction = nullptr;
-#endif
 	Object obj;
 	Ref refa = ano->getRef();
 
-	obj = xref->fetch(refa.num, refa.gen);
+	obj = m_xref->fetch(refa.num, refa.gen);
 	if (obj.isDict())
 	{
 		Dict* adic = obj.getDict();
-		POPPLER_CONST_075 Object POPPLER_REF additionalActions = adic->lookupNF("AA");
-		Object additionalActionsObject = additionalActions.fetch(pdfDoc->getXRef());
+		const Object & additionalActions = adic->lookupNF("AA");
+		Object additionalActionsObject = additionalActions.fetch(m_pdfDoc->getXRef());
 		if (additionalActionsObject.isDict())
 		{
 			Object actionObject = additionalActionsObject.dictLookup(key);
 			if (actionObject.isDict())
-				linkAction = LinkAction::parseAction(&actionObject, pdfDoc->getCatalog()->getBaseURI());
+				linkAction = LinkAction::parseAction(&actionObject, m_pdfDoc->getCatalog()->getBaseURI());
 		}
 	}
 	return linkAction;
 }
 
-GBool SlaOutputDev::annotations_callback(Annot *annota, void *user_data)
+bool SlaOutputDev::annotations_callback(Annot *annota, void *user_data)
 {
 	SlaOutputDev *dev = (SlaOutputDev*)user_data;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+	const PDFRectangle& annotRect = annota->getRect();;
+	const PDFRectangle* box = &annotRect;
+#else
 	PDFRectangle *box = annota->getRect();
+#endif
 	double xCoor = dev->m_doc->currentPage()->xOffset() + box->x1 - dev->cropOffsetX;
 	double yCoor = dev->m_doc->currentPage()->yOffset() + dev->m_doc->currentPage()->height() - box->y2 + dev->cropOffsetY;
 	double width = box->x2 - box->x1;
@@ -450,11 +459,11 @@
 	int pagNum = 0;
 	int xco = 0;
 	int yco = 0;
-	QString fileName = "";
+	QString fileName;
 	if (act->getKind() == actionGoTo)
 	{
 		LinkGoTo *gto = (LinkGoTo*) act;
-		POPPLER_CONST LinkDest *dst = gto->getDest();
+		const LinkDest *dst = gto->getDest();
 		if (dst)
 		{
 			if (dst->getKind() == destXYZ)
@@ -462,11 +471,7 @@
 				if (dst->isPageRef())
 				{
 					Ref dstr = dst->getPageRef();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 76, 0)
-					pagNum = pdfDoc->findPage(dstr);
-#else
-					pagNum = pdfDoc->findPage(dstr.num, dstr.gen);
-#endif
+					pagNum = m_pdfDoc->findPage(dstr);
 				}
 				else
 					pagNum = dst->getPageNum();
@@ -477,14 +482,10 @@
 		}
 		else
 		{
-			POPPLER_CONST GooString *ndst = gto->getNamedDest();
+			const GooString *ndst = gto->getNamedDest();
 			if (ndst)
 			{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
-				std::unique_ptr<LinkDest> dstn = pdfDoc->findDest(ndst);
-#else
-				LinkDest *dstn = pdfDoc->findDest(ndst);
-#endif
+				std::unique_ptr<LinkDest> dstn = m_pdfDoc->findDest(ndst);
 				if (dstn)
 				{
 					if (dstn->getKind() == destXYZ)
@@ -492,11 +493,7 @@
 						if (dstn->isPageRef())
 						{
 							Ref dstr = dstn->getPageRef();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 76, 0)
-							pagNum = pdfDoc->findPage(dstr);
-#else
-							pagNum = pdfDoc->findPage(dstr.num, dstr.gen);
-#endif
+							pagNum = m_pdfDoc->findPage(dstr);
 						}
 						else
 							pagNum = dstn->getPageNum();
@@ -512,7 +509,7 @@
 	{
 		LinkGoToR *gto = (LinkGoToR*)act;
 		fileName = UnicodeParsedString(gto->getFileName());
-		POPPLER_CONST LinkDest *dst = gto->getDest();
+		const LinkDest *dst = gto->getDest();
 		if (dst)
 		{
 			if (dst->getKind() == destXYZ)
@@ -525,14 +522,10 @@
 		}
 		else
 		{
-			POPPLER_CONST GooString *ndst = gto->getNamedDest();
+			const GooString *ndst = gto->getNamedDest();
 			if (ndst)
 			{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
-				std::unique_ptr<LinkDest> dstn = pdfDoc->findDest(ndst);
-#else
-				LinkDest *dstn = pdfDoc->findDest(ndst);
-#endif
+				std::unique_ptr<LinkDest> dstn = m_pdfDoc->findDest(ndst);
 				if (dstn)
 				{
 					if (dstn->getKind() == destXYZ)
@@ -670,51 +663,57 @@
 			bool bgFound = false;
 			if (achar)
 			{
-				POPPLER_CONST AnnotColor *bgCol = achar->getBackColor();
+				const AnnotColor *bgCol = achar->getBackColor();
 				if (bgCol)
 				{
 					bgFound = true;
-					m_currColorFill = getAnnotationColor(bgCol);
+					m_graphicStack.top().fillColor = getAnnotationColor(bgCol);
 				}
 				else
-					m_currColorFill = CommonStrings::None;
-				POPPLER_CONST AnnotColor *fgCol = achar->getBorderColor();
+					m_graphicStack.top().fillColor = CommonStrings::None;
+				const AnnotColor *fgCol = achar->getBorderColor();
 				if (fgCol)
 				{
 					fgFound = true;
-					m_currColorStroke = getAnnotationColor(fgCol);
+					m_graphicStack.top().strokeColor = getAnnotationColor(fgCol);
 				}
 				else
 				{
 					fgCol = achar->getBackColor();
 					if (fgCol)
-						m_currColorStroke = getAnnotationColor(fgCol);
+						m_graphicStack.top().strokeColor = getAnnotationColor(fgCol);
 					else
-						m_currColorStroke = CommonStrings::None;
+						m_graphicStack.top().strokeColor = CommonStrings::None;
 				}
 			}
-			QString m_currColorText = "Black";
+			QString currTextColor = "Black";
 			double fontSize = 12;
-			QString fontName = "";
-			QString itemText = "";
+			QString fontName;
+			QString itemText;
 			AnnotAppearance *apa = annota->getAppearStreams();
 			if (apa || !achar)
 			{
 				AnoOutputDev *annotOutDev = new AnoOutputDev(m_doc, m_importedColors);
-				Gfx *gfx = new Gfx(pdfDoc, annotOutDev, pdfDoc->getPage(m_actPage)->getResourceDict(), annota->getRect(), nullptr);
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+				const PDFRectangle& annotaRect = annota->getRect();
+				Gfx* gfx = new Gfx(m_pdfDoc, annotOutDev, m_pdfDoc->getPage(m_actPage)->getResourceDict(), &annotaRect, nullptr);
+#else
+				Gfx *gfx = new Gfx(m_pdfDoc, annotOutDev, m_pdfDoc->getPage(m_actPage)->getResourceDict(), annota->getRect(), nullptr);
+#endif
 				ano->draw(gfx, false);
 				if (!bgFound)
-					m_currColorFill = annotOutDev->currColorFill;
+					m_graphicStack.top().fillColor = annotOutDev->currColorFill;
 				if (!fgFound)
-					m_currColorStroke = annotOutDev->currColorStroke;
-				m_currColorText = annotOutDev->currColorText;
+					m_graphicStack.top().strokeColor = annotOutDev->currColorStroke;
+				currTextColor = annotOutDev->currColorText;
 				fontSize = annotOutDev->fontSize;
 				fontName = UnicodeParsedString(annotOutDev->fontName);
 				itemText = UnicodeParsedString(annotOutDev->itemText);
 				delete gfx;
 				delete annotOutDev;
 			}
-			int z = m_doc->itemAdd(PageItem::TextFrame, PageItem::Rectangle, xCoor, yCoor, width, height, 0, m_currColorFill, CommonStrings::None);
+			const auto& graphicState = m_graphicStack.top();
+			int z = m_doc->itemAdd(PageItem::TextFrame, PageItem::Rectangle, xCoor, yCoor, width, height, 0, graphicState.fillColor, CommonStrings::None);
 			PageItem *ite = m_doc->Items->at(z);
 			int flg = annota->getFlags();
 			if (!(flg & 16))
@@ -746,7 +745,7 @@
 				else if (bsty == AnnotBorder::borderUnderlined)
 					bsty = 2;
 				ite->annotation().setBorderStyle(bsty);
-				ite->annotation().setBorderColor(m_currColorStroke);
+				ite->annotation().setBorderColor(graphicState.strokeColor);
 				ite->annotation().setBorderWidth(qRound(brd->getWidth()));
 			}
 			else
@@ -755,15 +754,14 @@
 				ite->annotation().setBorderColor(CommonStrings::None);
 				ite->annotation().setBorderWidth(0);
 			}
-			QString tmTxt = "";
-			tmTxt = UnicodeParsedString(fm->getPartialName());
+			QString tmTxt(UnicodeParsedString(fm->getPartialName()));
 			if (!tmTxt.isEmpty())
 				ite->setItemName(tmTxt);
-			tmTxt = "";
+			tmTxt.clear();
 			tmTxt = UnicodeParsedString(fm->getAlternateUiName());
 			if (!tmTxt.isEmpty())
 				ite->annotation().setToolTip(tmTxt);
-			tmTxt = "";
+			tmTxt.clear();
 			if (achar)
 			{
 				tmTxt = UnicodeParsedString(achar->getRolloverCaption());
@@ -782,12 +780,12 @@
 				ite->annotation().setVis(3);
 			if (wtyp == Annotation::Button)
 			{
-				ite->setFillColor(m_currColorFill);
+				ite->setFillColor(graphicState.fillColor);
 				if (achar)
 					ite->itemText.insertChars(UnicodeParsedString(achar->getNormalCaption()));
 				else
 					ite->itemText.insertChars(itemText);
-				applyTextStyle(ite, fontName, m_currColorText, fontSize);
+				applyTextStyle(ite, fontName, currTextColor, fontSize);
 				ite->annotation().addToFlag(Annotation::Flag_PushButton);
 				FormWidgetButton *btn = (FormWidgetButton*)fm;
 				if (!btn->isReadOnly())
@@ -800,7 +798,7 @@
 				if (btn)
 				{
 					ite->itemText.insertChars(UnicodeParsedString(btn->getContent()));
-					applyTextStyle(ite, fontName, m_currColorText, fontSize);
+					applyTextStyle(ite, fontName, currTextColor, fontSize);
 					ite->itemText.trim();
 					if (btn->isMultiline())
 						ite->annotation().addToFlag(Annotation::Flag_Multiline);
@@ -863,7 +861,7 @@
 						}
 						ite->itemText.insertChars(inh);
 					}
-					applyTextStyle(ite, fontName, m_currColorText, fontSize);
+					applyTextStyle(ite, fontName, currTextColor, fontSize);
 					if (!btn->isReadOnly())
 						ite->annotation().addToFlag(Annotation::Flag_Edit);
 					handleActions(ite, ano);
@@ -888,7 +886,7 @@
 	{
 		Object obj1;
 		Ref refa = annota->getRef();
-		obj1 = xref->fetch(refa.num, refa.gen);
+		obj1 = m_xref->fetch(refa.num, refa.gen);
 		if (obj1.isDict())
 		{
 			Dict* dict = obj1.getDict();
@@ -900,7 +898,7 @@
 				QList<int> radList;
 				for (int i = 0; i < obj2.arrayGetLength(); i++)
 				{
-					POPPLER_CONST_075 Object POPPLER_REF childRef = obj2.arrayGetNF(i);
+					const Object & childRef = obj2.arrayGetNF(i);
 					if (!childRef.isRef())
 						continue;
 					Object childObj = obj2.arrayGet(i);
@@ -972,7 +970,7 @@
 			int xco = 0;
 			int yco = 0;
 			LinkGoTo *gto = (LinkGoTo*)Lact;
-			POPPLER_CONST LinkDest *dst = gto->getDest();
+			const LinkDest *dst = gto->getDest();
 			if (dst)
 			{
 				if (dst->getKind() == destXYZ)
@@ -980,11 +978,7 @@
 					if (dst->isPageRef())
 					{
 						Ref dstr = dst->getPageRef();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 76, 0)
-						pagNum = pdfDoc->findPage(dstr);
-#else
-						pagNum = pdfDoc->findPage(dstr.num, dstr.gen);
-#endif
+						pagNum = m_pdfDoc->findPage(dstr);
 					}
 					else
 						pagNum = dst->getPageNum();
@@ -997,14 +991,10 @@
 			}
 			else
 			{
-				POPPLER_CONST GooString *ndst = gto->getNamedDest();
+				const GooString *ndst = gto->getNamedDest();
 				if (ndst)
 				{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
-					std::unique_ptr<LinkDest> dstn = pdfDoc->findDest(ndst);
-#else
-					LinkDest *dstn = pdfDoc->findDest(ndst);
-#endif
+					std::unique_ptr<LinkDest> dstn = m_pdfDoc->findDest(ndst);
 					if (dstn)
 					{
 						if (dstn->getKind() == destXYZ)
@@ -1012,11 +1002,7 @@
 							if (dstn->isPageRef())
 							{
 								Ref dstr = dstn->getPageRef();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 76, 0)
-								pagNum = pdfDoc->findPage(dstr);
-#else
-								pagNum = pdfDoc->findPage(dstr.num, dstr.gen);
-#endif
+								pagNum = m_pdfDoc->findPage(dstr);
 							}
 							else
 								pagNum = dstn->getPageNum();
@@ -1037,7 +1023,7 @@
 			int yco = 0;
 			LinkGoToR *gto = (LinkGoToR*)Lact;
 			QString fileName = UnicodeParsedString(gto->getFileName());
-			POPPLER_CONST LinkDest *dst = gto->getDest();
+			const LinkDest *dst = gto->getDest();
 			if (dst)
 			{
 				if (dst->getKind() == destXYZ)
@@ -1053,14 +1039,10 @@
 			}
 			else
 			{
-				POPPLER_CONST GooString *ndst = gto->getNamedDest();
+				const GooString *ndst = gto->getNamedDest();
 				if (ndst)
 				{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
-					std::unique_ptr<LinkDest> dstn = pdfDoc->findDest(ndst);
-#else
-					LinkDest *dstn = pdfDoc->findDest(ndst);
-#endif
+					std::unique_ptr<LinkDest> dstn = m_pdfDoc->findDest(ndst);
 					if (dstn)
 					{
 						if (dstn->getKind() == destXYZ)
@@ -1134,143 +1116,91 @@
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setD_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("E", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setE_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("X", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setX_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("Fo", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setFo_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("Bl", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setBl_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("C", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setC_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("F", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setF_act(UnicodeParsedString(jsa->getScript()));
@@ -1278,22 +1208,14 @@
 				ite->annotation().setFormat(5);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("K", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setK_act(UnicodeParsedString(jsa->getScript()));
@@ -1301,59 +1223,42 @@
 				ite->annotation().setFormat(5);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 	Aact = SC_getAdditionalAction("V", ano);
 	if (Aact)
 	{
 		if (Aact->getKind() == actionJavaScript)
 		{
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 			LinkJavaScript *jsa = (LinkJavaScript*) Aact.get();
-#else
-			LinkJavaScript *jsa = (LinkJavaScript*) Aact;
-#endif
 			if (jsa->isOk())
 			{
 				ite->annotation().setV_act(UnicodeParsedString(jsa->getScript()));
 				ite->annotation().setAAact(true);
 			}
 		}
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 		Aact.reset();
-#else
-		Aact = nullptr;
-#endif
 	}
 }
 
 void SlaOutputDev::startDoc(PDFDoc *doc, XRef *xrefA, Catalog *catA)
 {
-	xref = xrefA;
-	catalog = catA;
-	pdfDoc = doc;
-	updateGUICounter = 0;
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 84, 0)
+	m_xref = xrefA;
+	m_catalog = catA;
+	m_pdfDoc = doc;
+	m_updateGUICounter = 0;
 	m_fontEngine = new SplashFontEngine(true, false, false, true);
-#else
-	m_fontEngine = new SplashFontEngine(globalParams->getEnableFreeType(), false, false, true);
-#endif
 }
 
 void SlaOutputDev::startPage(int pageNum, GfxState *, XRef *)
 {
-	m_formWidgets = pdfDoc->getPage(pageNum)->getFormWidgets();
+	m_formWidgets = m_pdfDoc->getPage(pageNum)->getFormWidgets();
 	m_radioMap.clear();
 	m_radioButtons.clear();
 	m_actPage = pageNum;
+	m_graphicStack.clear();
 	m_groupStack.clear();
 	pushGroup();
-	m_currentClipPath = QPainterPath();
-	m_clipPaths.clear();
 }
 
 void SlaOutputDev::endPage()
@@ -1362,19 +1267,19 @@
 	{
 		for (auto it = m_radioMap.begin(); it != m_radioMap.end(); ++it)
 		{
-			tmpSel->clear();
+			m_tmpSel->clear();
 			QList<int> refList = it.value();
 			for (int a = 0; a < refList.count(); a++)
 			{
 				if (m_radioButtons.contains(refList[a]))
 				{
-					tmpSel->addItem(m_radioButtons[refList[a]], true);
+					m_tmpSel->addItem(m_radioButtons[refList[a]], true);
 					m_Elements->removeAll(m_radioButtons[refList[a]]);
 				}
 			}
-			if (!tmpSel->isEmpty())
+			if (!m_tmpSel->isEmpty())
 			{
-				PageItem *ite = m_doc->groupObjectsSelection(tmpSel);
+				PageItem *ite = m_doc->groupObjectsSelection(m_tmpSel);
 				ite->setItemName(it.key());
 				m_Elements->append(ite);
 				if (m_groupStack.count() != 0)
@@ -1389,7 +1294,7 @@
 
 void SlaOutputDev::saveState(GfxState *state)
 {
-	m_clipPaths.push(m_currentClipPath);
+	m_graphicStack.save();
 	pushGroup();
 }
 
@@ -1402,16 +1307,16 @@
 		{
 			if ((gElements.Items.count() > 1) && (checkClip()))
 			{
-				tmpSel->clear();
+				m_tmpSel->clear();
 				for (int dre = 0; dre < gElements.Items.count(); ++dre)
 				{
-					tmpSel->addItem(gElements.Items.at(dre), true);
+					m_tmpSel->addItem(gElements.Items.at(dre), true);
 					m_Elements->removeAll(gElements.Items.at(dre));
 				}
-				PageItem *ite = m_doc->groupObjectsSelection(tmpSel);
+				PageItem *ite = m_doc->groupObjectsSelection(m_tmpSel);
 				if (ite)
 				{
-					QPainterPath clippath = m_currentClipPath;
+					QPainterPath clippath = m_graphicStack.top().clipPath;
 					clippath.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());
 					clippath.translate(-ite->xPos(), -ite->yPos());
 					ite->PoLine.fromQPainterPath(clippath, true);
@@ -1443,7 +1348,7 @@
 						}
 					}
 				}
-				tmpSel->clear();
+				m_tmpSel->clear();
 			}
 			else
 			{
@@ -1459,18 +1364,18 @@
 			}
 		}
 	}
-	if (m_clipPaths.count() != 0)
-		m_currentClipPath = m_clipPaths.pop();
+	
+	m_graphicStack.restore();
 }
 
-void SlaOutputDev::beginTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox, GfxColorSpace * /*blendingColorSpace*/, GBool isolated, GBool knockout, GBool forSoftMask)
+void SlaOutputDev::beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool isolated, bool knockout, bool forSoftMask)
 {
 // 	qDebug() << "SlaOutputDev::beginTransparencyGroup isolated:" << isolated << "knockout:" << knockout << "forSoftMask:" << forSoftMask;
 	pushGroup("", forSoftMask);
 	m_groupStack.top().isolated = isolated;
 }
 
-void SlaOutputDev::paintTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox)
+void SlaOutputDev::paintTransparencyGroup(GfxState *state, const double *bbox)
 {
 // 	qDebug() << "SlaOutputDev::paintTransparencyGroup";
 	if (m_groupStack.count() != 0)
@@ -1490,7 +1395,7 @@
 	if (m_groupStack.count() <= 0)
 		return;
 
-	tmpSel->clear();
+	m_tmpSel->clear();
 
 	groupEntry gElements = m_groupStack.pop();
 	if (gElements.Items.count() <= 0)
@@ -1500,10 +1405,10 @@
 	{
 		for (int dre = 0; dre < gElements.Items.count(); ++dre)
 		{
-			tmpSel->addItem(gElements.Items.at(dre), true);
+			m_tmpSel->addItem(gElements.Items.at(dre), true);
 			m_Elements->removeAll(gElements.Items.at(dre));
 		}
-		PageItem *ite = m_doc->groupObjectsSelection(tmpSel);
+		PageItem *ite = m_doc->groupObjectsSelection(m_tmpSel);
 		ite->setFillTransparency(1.0 - state->getFillOpacity());
 		ite->setFillBlendmode(getBlendMode(state));
 		ScPattern pat(m_doc);
@@ -1523,17 +1428,17 @@
 		QString id = QString("Pattern_from_PDF_%1S").arg(m_doc->docPatterns.count() + 1);
 		m_doc->addPattern(id, pat);
 		m_currentMask = id;
-		tmpSel->clear();
+		m_tmpSel->clear();
 		return;
 	}
 	PageItem *ite;
 	for (int dre = 0; dre < gElements.Items.count(); ++dre)
 	{
-		tmpSel->addItem(gElements.Items.at(dre), true);
+		m_tmpSel->addItem(gElements.Items.at(dre), true);
 		m_Elements->removeAll(gElements.Items.at(dre));
 	}
 	if ((gElements.Items.count() != 1) || (gElements.isolated))
-		ite = m_doc->groupObjectsSelection(tmpSel);
+		ite = m_doc->groupObjectsSelection(m_tmpSel);
 	else
 		ite = gElements.Items.first();
 	if (ite->isGroup())
@@ -1542,7 +1447,7 @@
 		ite->FrameType = 3;
 		if (checkClip())
 		{
-			QPainterPath clippath = m_currentClipPath;
+			QPainterPath clippath = m_graphicStack.top().clipPath;
 			clippath.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());
 			clippath.translate(-ite->xPos(), -ite->yPos());
 			ite->PoLine.fromQPainterPath(clippath, true);
@@ -1566,10 +1471,10 @@
 		m_groupStack.top().Items.append(ite);
 	}
 
-	tmpSel->clear();
+	m_tmpSel->clear();
 }
 
-void SlaOutputDev::setSoftMask(GfxState * /*state*/, POPPLER_CONST_070 double * bbox, GBool alpha, Function *transferFunc, GfxColor * /*backdropColor*/)
+void SlaOutputDev::setSoftMask(GfxState * /*state*/, const double * bbox, bool alpha, Function *transferFunc, GfxColor * /*backdropColor*/)
 {
 	if (m_groupStack.count() <= 0)
 		return;
@@ -1597,14 +1502,16 @@
 
 void SlaOutputDev::updateFillColor(GfxState *state)
 {
-	m_currFillShade = 100;
-	m_currColorFill = getColor(state->getFillColorSpace(), state->getFillColor(), &m_currFillShade);
+	auto& graphicState = m_graphicStack.top();
+	graphicState.fillShade = 100;
+	graphicState.fillColor = getColor(state->getFillColorSpace(), state->getFillColor(), &graphicState.fillShade);
 }
 
 void SlaOutputDev::updateStrokeColor(GfxState *state)
 {
-	m_currStrokeShade = 100;
-	m_currColorStroke = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &m_currStrokeShade);
+	auto& graphicState = m_graphicStack.top();
+	graphicState.strokeShade = 100;
+	graphicState.strokeColor = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &graphicState.strokeShade);
 }
 
 void SlaOutputDev::clip(GfxState *state)
@@ -1639,101 +1546,102 @@
 		// this information.
 		QPainterPath pathN = out.toQPainterPath(false);
 		pathN.setFillRule(fillRule);
-		m_currentClipPath = intersection(pathN, m_currentClipPath);
+		m_graphicStack.top().clipPath = intersection(pathN, m_graphicStack.top().clipPath);
 	}
 	else
-		m_currentClipPath = out.toQPainterPath(false);
+		m_graphicStack.top().clipPath = out.toQPainterPath(false);
 }
 
 void SlaOutputDev::stroke(GfxState *state)
 {
 //	qDebug() << "Stroke";
-	const double *ctm;
-	ctm = state->getCTM();
+	const double *ctm = state->getCTM();
 	double xCoor = m_doc->currentPage()->xOffset();
 	double yCoor = m_doc->currentPage()->yOffset();
-	QString output = convertPath(state->getPath());
 	getPenState(state);
-	if ((m_Elements->count() != 0) && (output == Coords))			// Path is the same as in last fill
+
+	auto& graphicState = m_graphicStack.top();
+	graphicState.strokeColor = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &graphicState.strokeShade);
+
+	QString output = convertPath(state->getPath());
+	if ((m_Elements->count() != 0) && (output == m_coords))			// Path is the same as in last fill
 	{
 		PageItem* ite = m_Elements->last();
-		ite->setLineColor(m_currColorStroke);
-		ite->setLineShade(m_currStrokeShade);
+		ite->setLineColor(graphicState.strokeColor);
+		ite->setLineShade(graphicState.strokeShade);
 		ite->setLineEnd(m_lineEnd);
 		ite->setLineJoin(m_lineJoin);
 		ite->setLineWidth(state->getTransformedLineWidth());
-		ite->setDashes(DashValues);
-		ite->setDashOffset(DashOffset);
+		ite->setDashes(m_dashValues);
+		ite->setDashOffset(m_dashOffset);
 		ite->setLineTransparency(1.0 - state->getStrokeOpacity());
+		return;
 	}
+
+	FPointArray out;
+	out.parseSVG(output);
+	m_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
+	out.map(m_ctm);
+	FPoint wh = out.widthHeight();
+	if ((out.size() <= 3) || ((wh.x() <= 0.0) && (wh.y() <= 0.0)))
+		return;
+
+	int z;
+	if (m_pathIsClosed)
+		z = m_doc->itemAdd(PageItem::Polygon, PageItem::Unspecified, xCoor, yCoor, 10, 10, state->getTransformedLineWidth(), CommonStrings::None, graphicState.strokeColor);
 	else
+		z = m_doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, xCoor, yCoor, 10, 10, state->getTransformedLineWidth(), CommonStrings::None, graphicState.strokeColor);
+	PageItem* ite = m_doc->Items->at(z);
+	ite->PoLine = out.copy();
+	ite->ClipEdited = true;
+	ite->FrameType = 3;
+	ite->setWidthHeight(wh.x(), wh.y());
+	m_doc->adjustItemSize(ite);
+	if (m_Elements->count() != 0)
 	{
-		FPointArray out;
-		out.parseSVG(output);
-		m_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
-		out.map(m_ctm);
-		FPoint wh = out.widthHeight();
-		if ((out.size() > 3) && ((wh.x() != 0.0) || (wh.y() != 0.0)))
-		{
-			m_currColorStroke = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &m_currStrokeShade);
-			int z;
-			if (pathIsClosed)
-				z = m_doc->itemAdd(PageItem::Polygon, PageItem::Unspecified, xCoor, yCoor, 10, 10, state->getTransformedLineWidth(), CommonStrings::None, m_currColorStroke);
-			else
-				z = m_doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, xCoor, yCoor, 10, 10, state->getTransformedLineWidth(), CommonStrings::None, m_currColorStroke);
-			PageItem* ite = m_doc->Items->at(z);
-			ite->PoLine = out.copy();
-			ite->ClipEdited = true;
-			ite->FrameType = 3;
-			ite->setWidthHeight(wh.x(), wh.y());
-			m_doc->adjustItemSize(ite);
-			if (m_Elements->count() != 0)
-			{
-				PageItem* lItem = m_Elements->last();
-				if ((lItem->lineColor() == CommonStrings::None) && (lItem->PoLine == ite->PoLine))
-				{
-					lItem->setLineColor(m_currColorStroke);
-					lItem->setLineWidth(state->getTransformedLineWidth());
-					lItem->setLineShade(m_currStrokeShade);
-					lItem->setLineTransparency(1.0 - state->getStrokeOpacity());
-					lItem->setLineBlendmode(getBlendMode(state));
-					lItem->setLineEnd(m_lineEnd);
-					lItem->setLineJoin(m_lineJoin);
-					lItem->setDashes(DashValues);
-					lItem->setDashOffset(DashOffset);
-					lItem->setTextFlowMode(PageItem::TextFlowDisabled);
-					m_doc->Items->removeAll(ite);
-				}
-				else
-				{
-					ite->setLineShade(m_currStrokeShade);
-					ite->setLineTransparency(1.0 - state->getStrokeOpacity());
-					ite->setLineBlendmode(getBlendMode(state));
-					ite->setLineEnd(m_lineEnd);
-					ite->setLineJoin(m_lineJoin);
-					ite->setDashes(DashValues);
-					ite->setDashOffset(DashOffset);
-					ite->setTextFlowMode(PageItem::TextFlowDisabled);
-					m_Elements->append(ite);
-					if (m_groupStack.count() != 0)
-						m_groupStack.top().Items.append(ite);
-				}
-			}
-			else
-			{
-				ite->setLineShade(m_currStrokeShade);
-				ite->setLineTransparency(1.0 - state->getStrokeOpacity());
-				ite->setLineBlendmode(getBlendMode(state));
-				ite->setLineEnd(m_lineEnd);
-				ite->setLineJoin(m_lineJoin);
-				ite->setDashes(DashValues);
-				ite->setDashOffset(DashOffset);
-				ite->setTextFlowMode(PageItem::TextFlowDisabled);
-				m_Elements->append(ite);
-				if (m_groupStack.count() != 0)
-					m_groupStack.top().Items.append(ite);
-			}
+		PageItem* lItem = m_Elements->last();
+		if ((lItem->lineColor() == CommonStrings::None) && (lItem->PoLine == ite->PoLine))
+		{
+			lItem->setLineColor(graphicState.strokeColor);
+			lItem->setLineWidth(state->getTransformedLineWidth());
+			lItem->setLineShade(graphicState.strokeShade);
+			lItem->setLineTransparency(1.0 - state->getStrokeOpacity());
+			lItem->setLineBlendmode(getBlendMode(state));
+			lItem->setLineEnd(m_lineEnd);
+			lItem->setLineJoin(m_lineJoin);
+			lItem->setDashes(m_dashValues);
+			lItem->setDashOffset(m_dashOffset);
+			lItem->setTextFlowMode(PageItem::TextFlowDisabled);
+			m_doc->Items->removeAll(ite);
 		}
+		else
+		{
+			ite->setLineShade(graphicState.strokeShade);
+			ite->setLineTransparency(1.0 - state->getStrokeOpacity());
+			ite->setLineBlendmode(getBlendMode(state));
+			ite->setLineEnd(m_lineEnd);
+			ite->setLineJoin(m_lineJoin);
+			ite->setDashes(m_dashValues);
+			ite->setDashOffset(m_dashOffset);
+			ite->setTextFlowMode(PageItem::TextFlowDisabled);
+			m_Elements->append(ite);
+			if (m_groupStack.count() != 0)
+				m_groupStack.top().Items.append(ite);
+		}
+	}
+	else
+	{
+		ite->setLineShade(graphicState.strokeShade);
+		ite->setLineTransparency(1.0 - state->getStrokeOpacity());
+		ite->setLineBlendmode(getBlendMode(state));
+		ite->setLineEnd(m_lineEnd);
+		ite->setLineJoin(m_lineJoin);
+		ite->setDashes(m_dashValues);
+		ite->setDashOffset(m_dashOffset);
+		ite->setTextFlowMode(PageItem::TextFlowDisabled);
+		m_Elements->append(ite);
+		if (m_groupStack.count() != 0)
+			m_groupStack.top().Items.append(ite);
 	}
 }
 
@@ -1761,10 +1669,12 @@
 	out.parseSVG(output);
 	out.map(m_ctm);
 
+	auto& graphicState = m_graphicStack.top();
+
 	// Clip the new path first and only add it if it is not empty.
 	QPainterPath path = out.toQPainterPath(false);
 	path.setFillRule(fillRule);
-	QPainterPath clippedPath = intersection(m_currentClipPath, path);
+	QPainterPath clippedPath = intersection(graphicState.clipPath, path);
 
 	// Undo the rotation of the clipping path as it is rotated together with the item.
 	double angle = m_ctm.map(QLineF(0, 0, 1, 0)).angle();
@@ -1772,21 +1682,21 @@
 	mm.rotate(angle);
 	clippedPath = mm.map(clippedPath);
 
-	Coords = output;
+	m_coords = output;
 	QRectF bbox = clippedPath.boundingRect();
 	if (!clippedPath.isEmpty() && !bbox.isNull())
 	{
-		m_currColorFill = getColor(state->getFillColorSpace(), state->getFillColor(), &m_currFillShade);
+		graphicState.fillColor = getColor(state->getFillColorSpace(), state->getFillColor(), &graphicState.fillShade);
 		int z;
-		if (pathIsClosed)
-			z = m_doc->itemAdd(PageItem::Polygon, PageItem::Unspecified, xCoor, yCoor, 10, 10, 0, m_currColorFill, CommonStrings::None);
+		if (m_pathIsClosed)
+			z = m_doc->itemAdd(PageItem::Polygon, PageItem::Unspecified, xCoor, yCoor, 10, 10, 0, graphicState.fillColor, CommonStrings::None);
 		else
-			z = m_doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, xCoor, yCoor, 10, 10, 0, m_currColorFill, CommonStrings::None);
+			z = m_doc->itemAdd(PageItem::PolyLine, PageItem::Unspecified, xCoor, yCoor, 10, 10, 0, graphicState.fillColor, CommonStrings::None);
 		PageItem* ite = m_doc->Items->at(z);
 		ite->PoLine.fromQPainterPath(clippedPath, true);
 		ite->ClipEdited = true;
 		ite->FrameType = 3;
-		ite->setFillShade(m_currFillShade);
+		ite->setFillShade(graphicState.fillShade);
 		ite->setLineShade(100);
 		ite->setRotation(-angle);
 		// Only the new path has to be interpreted according to fillRule. QPainterPath
@@ -1809,7 +1719,7 @@
 	}
 }
 
-GBool SlaOutputDev::axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax)
+bool SlaOutputDev::axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax)
 {
 //	qDebug() << "SlaOutputDev::axialShadedFill";
 	double GrStartX;
@@ -1817,7 +1727,7 @@
 	double GrEndX;
 	double GrEndY;
 	int shade = 100;
-	POPPLER_CONST_070 Function *func = shading->getFunc(0);
+	const Function *func = shading->getFunc(0);
 	VGradient FillGradient = VGradient(VGradient::linear);
 	FillGradient.clearStops();
 	GfxColorSpace *color_space = shading->getColorSpace();
@@ -1866,7 +1776,7 @@
 	{
 		// Apply the clip path early to adjust the gradient vector to the
 		// smaller boundign box.
-		out = intersection(m_currentClipPath, out);
+		out = intersection(m_graphicStack.top().clipPath, out);
 		crect = out.boundingRect();
 	}
 	const double *ctm = state->getCTM();
@@ -1899,9 +1809,11 @@
 	output += QString("L %1 %2").arg(0.0).arg(crect.height());
 	output += QString("L %1 %2").arg(0.0).arg(0.0);
 	output += QString("Z");
-	pathIsClosed = true;
-	Coords = output;
-	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), bb.width(), bb.height(), 0, m_currColorFill, CommonStrings::None);
+	m_pathIsClosed = true;
+	m_coords = output;
+
+	const auto& graphicState = m_graphicStack.top();
+	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), bb.width(), bb.height(), 0, graphicState.fillColor, CommonStrings::None);
 	PageItem* ite = m_doc->Items->at(z);
 	if (checkClip())
 	{
@@ -1911,7 +1823,7 @@
 	ite->setRotation(-angle);
 	ite->ClipEdited = true;
 	ite->FrameType = 3;
-	ite->setFillShade(m_currFillShade);
+	ite->setFillShade(graphicState.fillShade);
 	ite->setLineShade(100);
 	ite->setFillTransparency(1.0 - state->getFillOpacity());
 	ite->setFillBlendmode(getBlendMode(state));
@@ -1938,10 +1850,10 @@
 		m_groupStack.top().Items.append(ite);
 		applyMask(ite);
 	}
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)
+bool SlaOutputDev::radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax)
 {
 //	qDebug() << "SlaOutputDev::radialShadedFill";
 	double GrStartX;
@@ -1949,7 +1861,7 @@
 	double GrEndX;
 	double GrEndY;
 	int shade = 100;
-	POPPLER_CONST_070 Function *func = shading->getFunc(0);
+	const Function *func = shading->getFunc(0);
 	VGradient FillGradient = VGradient(VGradient::linear);
 	FillGradient.clearStops();
 	GfxColorSpace *color_space = shading->getColorSpace();
@@ -1986,6 +1898,7 @@
 		QString stopColor2 = getColor(color_space, &stop2, &shade);
 		FillGradient.addStop( ScColorEngine::getShadeColor(m_doc->PageColors[stopColor2], m_doc, shade), 1.0, 0.5, 1.0, stopColor2, shade );
 	}
+
 	double r0, x1, y1, r1;
 	shading->getCoords(&GrStartX, &GrStartY, &r0, &x1, &y1, &r1);
 	double xmin, ymin, xmax, ymax;
@@ -2018,13 +1931,15 @@
 	output += QString("L %1 %2").arg(0.0).arg(crect.height());
 	output += QString("L %1 %2").arg(0.0).arg(0.0);
 	output += QString("Z");
-	pathIsClosed = true;
-	Coords = output;
-	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, m_currColorFill, CommonStrings::None);
+	m_pathIsClosed = true;
+	m_coords = output;
+
+	const auto& graphicState = m_graphicStack.top();
+	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);
 	PageItem* ite = m_doc->Items->at(z);
 	if (checkClip())
 	{
-		QPainterPath out = m_currentClipPath;
+		QPainterPath out = graphicState.clipPath;
 		out.translate(m_doc->currentPage()->xOffset(), m_doc->currentPage()->yOffset());
 		out.translate(-ite->xPos(), -ite->yPos());
 		ite->PoLine.fromQPainterPath(out, true);
@@ -2032,7 +1947,7 @@
 	}
 	ite->ClipEdited = true;
 	ite->FrameType = 3;
-	ite->setFillShade(m_currFillShade);
+	ite->setFillShade(graphicState.fillShade);
 	ite->setLineShade(100);
 	ite->setFillTransparency(1.0 - state->getFillOpacity());
 	ite->setFillBlendmode(getBlendMode(state));
@@ -2059,10 +1974,10 @@
 		m_groupStack.top().Items.append(ite);
 		applyMask(ite);
 	}
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)
+bool SlaOutputDev::gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading)
 {
 //	qDebug() << "SlaOutputDev::gouraudTriangleShadedFill";
 	double xCoor = m_doc->currentPage()->xOffset();
@@ -2078,15 +1993,16 @@
 	output += QString("L %1 %2").arg(0.0).arg(crect.height());
 	output += QString("L %1 %2").arg(0.0).arg(0.0);
 	output += QString("Z");
-	pathIsClosed = true;
-	Coords = output;
+	m_pathIsClosed = true;
+	m_coords = output;
 	const double *ctm = state->getCTM();
 	m_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
-	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, m_currColorFill, CommonStrings::None);
+	const auto& graphicState = m_graphicStack.top();
+	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);
 	PageItem* ite = m_doc->Items->at(z);
 	ite->ClipEdited = true;
 	ite->FrameType = 3;
-	ite->setFillShade(m_currFillShade);
+	ite->setFillShade(graphicState.fillShade);
 	ite->setLineShade(100);
 	ite->setFillEvenOdd(false);
 	ite->setFillTransparency(1.0 - state->getFillOpacity());
@@ -2139,10 +2055,10 @@
 		ite->meshGradientPatches.append(patchM);
 	}
 	ite->GrType = 12;
-	return gTrue;
+	return true;
 }
 
-GBool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)
+bool SlaOutputDev::patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading)
 {
 //	qDebug() << "SlaOutputDev::patchMeshShadedFill";
 	double xCoor = m_doc->currentPage()->xOffset();
@@ -2158,15 +2074,16 @@
 	output += QString("L %1 %2").arg(0.0).arg(crect.height());
 	output += QString("L %1 %2").arg(0.0).arg(0.0);
 	output += QString("Z");
-	pathIsClosed = true;
-	Coords = output;
+	m_pathIsClosed = true;
+	m_coords = output;
 	const double *ctm = state->getCTM();
 	m_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
-	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, m_currColorFill, CommonStrings::None);
+	const auto& graphicState = m_graphicStack.top();
+	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);
 	PageItem* ite = m_doc->Items->at(z);
 	ite->ClipEdited = true;
 	ite->FrameType = 3;
-	ite->setFillShade(m_currFillShade);
+	ite->setFillShade(graphicState.fillShade);
 	ite->setLineShade(100);
 	ite->setFillEvenOdd(false);
 	ite->setFillTransparency(1.0 - state->getFillOpacity());
@@ -2288,21 +2205,15 @@
 		ite->meshGradientPatches.append(patchM);
 	}
 	ite->GrType = 12;
-	return gTrue;
+	return true;
 }
 
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
-#else
-GBool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, Object *str, POPPLER_CONST_070 double *pmat, int /*paintType*/, int /*tilingType*/, Dict *resDict, POPPLER_CONST_070 double *mat, POPPLER_CONST_070 double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep)
-#endif
 {
 //	qDebug() << "SlaOutputDev::tilingPatternFill";
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	const double *bbox = tPat->getBBox();
 	const double *pmat = tPat->getMatrix();
 	Dict *resDict = tPat->getResDict();
-#endif
 
 	PDFRectangle box;
 	Gfx *gfx;
@@ -2314,7 +2225,7 @@
 	width = bbox[2] - bbox[0];
 	height = bbox[3] - bbox[1];
 	if (xStep != width || yStep != height)
-		return gFalse;
+		return false;
 	box.x1 = bbox[0];
 	box.y1 = bbox[1];
 	box.x2 = bbox[2];
@@ -2325,22 +2236,17 @@
 	QTransform mm = QTransform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);
 	QTransform mmx = mm * m_ctm;
 
-	gfx = new Gfx(pdfDoc, this, resDict, &box, nullptr);
-	inPattern++;
+	gfx = new Gfx(m_pdfDoc, this, resDict, &box, nullptr);
+	m_inPattern++;
 	// Unset the clip path as it is unrelated to the pattern's coordinate space.
-	QPainterPath savedClip = m_currentClipPath;
-	m_currentClipPath = QPainterPath();
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
+	QPainterPath savedClip = m_graphicStack.top().clipPath;
+	m_graphicStack.top().clipPath = QPainterPath();
 	gfx->display(tPat->getContentStream());
-#else
-	gfx->display(str);
-#endif
-	m_currentClipPath = savedClip;
-	inPattern--;
-	gElements = m_groupStack.pop();
+	m_graphicStack.top().clipPath = savedClip;
+	m_inPattern--;
 	m_doc->m_Selection->clear();
-//	double pwidth = 0;
-//	double pheight = 0;
+
+	gElements = m_groupStack.pop();
 	if (gElements.Items.count() > 0)
 	{
 		for (int dre = 0; dre < gElements.Items.count(); ++dre)
@@ -2365,8 +2271,6 @@
 		m_doc->DoDrawing = false;
 		pat.width = ite->width();
 		pat.height = ite->height();
-	//	pwidth = ite->width();
-	//	pheight = ite->height();
 		ite->gXpos = 0;
 		ite->gYpos = 0;
 		ite->setXYPos(ite->gXpos, ite->gYpos, true);
@@ -2388,9 +2292,11 @@
 	output += QString("L %1 %2").arg(0.0).arg(crect.height());
 	output += QString("L %1 %2").arg(0.0).arg(0.0);
 	output += QString("Z");
-	pathIsClosed = true;
-	Coords = output;
-	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, m_currColorFill, CommonStrings::None);
+	m_pathIsClosed = true;
+	m_coords = output;
+
+	const auto& graphicState = m_graphicStack.top();
+	int z = m_doc->itemAdd(PageItem::Polygon, PageItem::Rectangle, xCoor + crect.x(), yCoor + crect.y(), crect.width(), crect.height(), 0, graphicState.fillColor, CommonStrings::None);
 	ite = m_doc->Items->at(z);
 
 	m_ctm = QTransform(ctm[0], ctm[1], ctm[2], ctm[3], ctm[4], ctm[5]);
@@ -2398,7 +2304,7 @@
 	ite->setRotation(-angle);
 	if (checkClip())
 	{
-		QPainterPath outline = m_currentClipPath;
+		QPainterPath outline = graphicState.clipPath;
 		outline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());
 		// Undo the rotation of the clipping path as it is rotated together with the item.
 		QTransform mm;
@@ -2409,7 +2315,7 @@
 	}
 	ite->ClipEdited = true;
 	ite->FrameType = 3;
-	ite->setFillShade(m_currFillShade);
+	ite->setFillShade(graphicState.fillShade);
 	ite->setLineShade(100);
 	ite->setFillTransparency(1.0 - state->getFillOpacity());
 	ite->setFillBlendmode(getBlendMode(state));
@@ -2427,10 +2333,10 @@
 		applyMask(ite);
 	}
 	delete gfx;
-	return gTrue;
+	return true;
 }
 
-void SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, GBool invert, GBool interpolate, GBool inlineImg)
+void SlaOutputDev::drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg)
 {
 //	qDebug() << "Draw Image Mask";
 	QImage * image = nullptr;
@@ -2439,7 +2345,7 @@
 	int x, y, i, bit;
 	unsigned char *dest = nullptr;
 	unsigned char *buffer;
-	Guchar *pix;
+	unsigned char *pix;
 	ImageStream * imgStr = new ImageStream(str, width, 1, 1);
 	imgStr->reset();
 #ifdef WORDS_BIGENDIAN
@@ -2482,7 +2388,8 @@
 			}
 		}
 	}
-	QColor backColor = ScColorEngine::getShadeColorProof(m_doc->PageColors[m_currColorFill], m_doc, m_currFillShade);
+	const auto& graphicState = m_graphicStack.top();
+	QColor backColor = ScColorEngine::getShadeColorProof(m_doc->PageColors[graphicState.fillColor], m_doc, graphicState.fillShade);
 	QImage res = QImage(width, height, QImage::Format_ARGB32);
 	res.fill(backColor.rgb());
 	unsigned char cc, cm, cy, ck;
@@ -2510,8 +2417,8 @@
 	delete image;
 }
 
-void SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, Stream *maskStr, int maskWidth, int maskHeight,
-				   GfxImageColorMap *maskColorMap, GBool maskInterpolate)
+void SlaOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight,
+				   GfxImageColorMap *maskColorMap, bool maskInterpolate)
 {
 //	qDebug() << "SlaOutputDev::drawSoftMaskedImage Masked Image Components" << colorMap->getNumPixelComps();
 	ImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
@@ -2522,7 +2429,7 @@
 	for (int y = 0; y < height; y++)
 	{
 		dest = (unsigned int *)(buffer + y * 4 * width);
-		Guchar * pix = imgStr->getLine();
+		unsigned char * pix = imgStr->getLine();
 		colorMap->getRGBLine(pix, dest, width);
 	}
 	image = new QImage(buffer, width, height, QImage::Format_RGB32);
@@ -2535,13 +2442,13 @@
 	}
 	ImageStream *mskStr = new ImageStream(maskStr, maskWidth, maskColorMap->getNumPixelComps(), maskColorMap->getBits());
 	mskStr->reset();
-	Guchar *mdest = nullptr;
+	unsigned char *mdest = nullptr;
 	unsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];
 	memset(mbuffer, 0, maskWidth * maskHeight);
 	for (int y = 0; y < maskHeight; y++)
 	{
-		mdest = (Guchar *)(mbuffer + y * maskWidth);
-		Guchar * pix = mskStr->getLine();
+		mdest = (unsigned char *)(mbuffer + y * maskWidth);
+		unsigned char * pix = mskStr->getLine();
 		maskColorMap->getGrayLine(pix, mdest, maskWidth);
 	}
 	if ((maskWidth != width) || (maskHeight != height))
@@ -2549,7 +2456,7 @@
 	QImage res = image->convertToFormat(QImage::Format_ARGB32);
 
 	int matteRc, matteGc, matteBc;
-	POPPLER_CONST_070 GfxColor *matteColor = maskColorMap->getMatteColor();
+	const GfxColor *matteColor = maskColorMap->getMatteColor();
 	if (matteColor != nullptr)
 	{
 		GfxRGB matteRgb;
@@ -2591,7 +2498,7 @@
 	delete[] mbuffer;
 }
 
-void SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, GBool interpolate, Stream *maskStr, int maskWidth, int maskHeight, GBool maskInvert, GBool maskInterpolate)
+void SlaOutputDev::drawMaskedImage(GfxState *state, Object *ref, Stream *str,  int width, int height, GfxImageColorMap *colorMap, bool interpolate, Stream *maskStr, int maskWidth, int maskHeight, bool maskInvert, bool maskInterpolate)
 {
 //	qDebug() << "SlaOutputDev::drawMaskedImage";
 	ImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
@@ -2602,7 +2509,7 @@
 	for (int y = 0; y < height; y++)
 	{
 		dest = (unsigned int *)(buffer + y * 4 * width);
-		Guchar * pix = imgStr->getLine();
+		unsigned char * pix = imgStr->getLine();
 		colorMap->getRGBLine(pix, dest, width);
 	}
 	image = new QImage(buffer, width, height, QImage::Format_RGB32);
@@ -2615,14 +2522,14 @@
 	}
 	ImageStream *mskStr = new ImageStream(maskStr, maskWidth, 1, 1);
 	mskStr->reset();
-	Guchar *mdest = nullptr;
+	unsigned char *mdest = nullptr;
 	int invert_bit = maskInvert ? 1 : 0;
 	unsigned char * mbuffer = new unsigned char[maskWidth * maskHeight];
 	memset(mbuffer, 0, maskWidth * maskHeight);
 	for (int y = 0; y < maskHeight; y++)
 	{
-		mdest = (Guchar *)(mbuffer + y * maskWidth);
-		Guchar * pix = mskStr->getLine();
+		mdest = (unsigned char *)(mbuffer + y * maskWidth);
+		unsigned char * pix = mskStr->getLine();
 		for (int x = 0; x < maskWidth; x++)
 		{
 			if (pix[x] ^ invert_bit)
@@ -2660,7 +2567,7 @@
 	delete[] mbuffer;
 }
 
-void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int* maskColors, GBool inlineImg)
+void SlaOutputDev::drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, const int* maskColors, bool inlineImg)
 {
 	ImageStream * imgStr = new ImageStream(str, width, colorMap->getNumPixelComps(), colorMap->getBits());
 //	qDebug() << "SlaOutputDev::drawImage Image Components" << colorMap->getNumPixelComps() << "Mask" << maskColors;
@@ -2672,7 +2579,7 @@
 		for (int y = 0; y < height; y++)
 		{
 			QRgb *s = (QRgb*)(image->scanLine(y));
-			Guchar *pix = imgStr->getLine();
+			unsigned char *pix = imgStr->getLine();
 			for (int x = 0; x < width; x++)
 			{
 				GfxRGB rgb;
@@ -2700,7 +2607,7 @@
 		for (int y = 0; y < height; y++)
 		{
 			QRgb *s = (QRgb*)(image->scanLine(y));
-			Guchar *pix = imgStr->getLine();
+			unsigned char *pix = imgStr->getLine();
 			for (int x = 0; x < width; x++)
 			{
 				if (colorMap->getNumPixelComps() == 4)
@@ -2765,9 +2672,9 @@
 	QPainterPath outline;
 	outline.addRect(0, 0, 1, 1);
 	outline = m_ctm.map(outline);
-	outline = intersection(outline, m_currentClipPath);
+	outline = intersection(outline, m_graphicStack.top().clipPath);
 
-	if ((inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))
+	if ((m_inPattern == 0) && (outline.isEmpty() || outline.boundingRect().isNull()))
 		return;
 
     // Determine the width and height of the image by undoing the rotation part
@@ -2868,7 +2775,7 @@
 		}
 		delete tempFile;
 	}
-	if (inPattern == 0)
+	if (m_inPattern == 0)
 	{
 		outline.translate(xCoor - ite->xPos(), yCoor - ite->yPos());
 		// Undo the rotation of the clipping path as it is rotated together with the image.
@@ -2888,19 +2795,19 @@
 	}
 }
 
-void SlaOutputDev::beginMarkedContent(POPPLER_CONST char *name, Object *dictRef)
+void SlaOutputDev::beginMarkedContent(const char *name, Object *dictRef)
 {
 	mContent mSte;
 	mSte.name = QString(name);
 	mSte.ocgName = "";
-	if (importerFlags & LoadSavePlugin::lfCreateDoc)
+	if (m_importerFlags & LoadSavePlugin::lfCreateDoc)
 	{
 		if (dictRef->isNull())
 			return;
 		Object dictObj;
 		Dict *dict;
 		Object dictType;
-		OCGs *contentConfig = catalog->getOptContentConfig();
+		OCGs *contentConfig = m_catalog->getOptContentConfig();
 		OptionalContentGroup *oc;
 		if (dictRef->isRef())
 		{
@@ -2914,7 +2821,7 @@
 		}
 		else
 		{
-			dictObj = dictRef->fetch(xref);
+			dictObj = dictRef->fetch(m_xref);
 			if (!dictObj.isDict())
 				return;
 			dict = dictObj.getDict();
@@ -2934,7 +2841,7 @@
 	m_mcStack.push(mSte);
 }
 
-void SlaOutputDev::beginMarkedContent(POPPLER_CONST char *name, Dict *properties)
+void SlaOutputDev::beginMarkedContent(const char *name, Dict *properties)
 {
 //	qDebug() << "Begin Marked Content with Name " << QString(name);
 	QString nam = QString(name);
@@ -2942,16 +2849,16 @@
 	mSte.name = nam;
 	mSte.ocgName = "";
 	m_mcStack.push(mSte);
-	if (importerFlags & LoadSavePlugin::lfCreateDoc)
+	if (m_importerFlags & LoadSavePlugin::lfCreateDoc)
 	{
 		if (nam == "Layer")		// Handle Adobe Illustrator Layer command
 		{
 			if (layersSetByOCG)
 				return;
-			QString lName = QString("Layer_%1").arg(layerNum + 1);
+			QString lName = QString("Layer_%1").arg(m_layerNum + 1);
 			Object obj = properties->lookup((char*) "Title");
 			if (obj.isString())
-				lName = QString(obj.getString()->getCString());
+				lName = QString(obj.getString()->c_str());
 			for (ScLayers::iterator it = m_doc->Layers.begin(); it != m_doc->Layers.end(); ++it)
 			{
 				if (it->Name == lName)
@@ -2960,20 +2867,20 @@
 					return;
 				}
 			}
-			layerNum++;
-			if (!firstLayer)
-				currentLayer = m_doc->addLayer(lName, true);
-			firstLayer = false;
+			m_layerNum++;
+			if (!m_firstLayer)
+				m_currentLayer = m_doc->addLayer(lName, true);
+			m_firstLayer = false;
 
 			obj = properties->lookup((char*) "Visible");
 			if (obj.isBool())
-				m_doc->setLayerVisible(currentLayer, obj.getBool());
+				m_doc->setLayerVisible(m_currentLayer, obj.getBool());
 			obj = properties->lookup((char*) "Editable");
 			if (obj.isBool())
-				m_doc->setLayerLocked(currentLayer, !obj.getBool());
+				m_doc->setLayerLocked(m_currentLayer, !obj.getBool());
 			obj = properties->lookup((char*) "Printed");
 			if (obj.isBool())
-				m_doc->setLayerPrintable(currentLayer, obj.getBool());
+				m_doc->setLayerPrintable(m_currentLayer, obj.getBool());
 			obj = properties->lookup((char*)"Color");
 			if (obj.isArray())
 			{
@@ -2984,7 +2891,7 @@
 				int g = obj1.getNum() / 256;
 				obj1 = obj.arrayGet(2);
 				int b = obj1.getNum() / 256;
-				m_doc->setLayerMarker(currentLayer, QColor(r, g, b));
+				m_doc->setLayerMarker(m_currentLayer, QColor(r, g, b));
 			}
 		}
 	}
@@ -2996,7 +2903,7 @@
 	if (m_mcStack.count() > 0)
 	{
 		mContent mSte = m_mcStack.pop();
-		if (importerFlags & LoadSavePlugin::lfCreateDoc)
+		if (m_importerFlags & LoadSavePlugin::lfCreateDoc)
 		{
 			if (mSte.name == "OC")
 			{
@@ -3013,12 +2920,12 @@
 	}
 }
 
-void SlaOutputDev::markPoint(POPPLER_CONST char *name)
+void SlaOutputDev::markPoint(const char *name)
 {
 //	qDebug() << "Begin Marked Point with Name " << QString(name);
 }
 
-void SlaOutputDev::markPoint(POPPLER_CONST char *name, Dict *properties)
+void SlaOutputDev::markPoint(const char *name, Dict *properties)
 {
 //	qDebug() << "Begin Marked Point with Name " << QString(name) << "and Properties";
 	beginMarkedContent(name, properties);
@@ -3026,19 +2933,30 @@
 
 void SlaOutputDev::updateFont(GfxState *state)
 {
-	GfxFont *gfxFont;
-	GfxFontLoc *fontLoc;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+	std::optional<GfxFontLoc> fontLoc;
+	std::string fileName;
+	std::unique_ptr<FoFiTrueType> ff;
+	std::optional<std::vector<unsigned char>> tmpBuf;
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+	std::optional<GfxFontLoc> fontLoc;
+	const GooString * fileName = nullptr;
+	std::unique_ptr<FoFiTrueType> ff;
+	char* tmpBuf = nullptr;
+#else
+	GfxFontLoc * fontLoc = nullptr;
+	GooString * fileName = nullptr;
+	FoFiTrueType * ff = nullptr;
+	char* tmpBuf = nullptr;
+#endif
 	GfxFontType fontType;
 	SlaOutFontFileID *id;
 	SplashFontFile *fontFile;
 	SplashFontSrc *fontsrc = nullptr;
-	FoFiTrueType *ff;
 	Object refObj, strObj;
-	GooString *fileName;
-	char *tmpBuf;
 	int tmpBufLen = 0;
-	int *codeToGID;
-	const double *textMat;
+	int *codeToGID = nullptr;
+	const double *textMat = nullptr;
 	double m11, m12, m21, m22, fontSize;
 	SplashCoord mat[4];
 	int n = 0;
@@ -3046,11 +2964,12 @@
 	SplashCoord matrix[6];
 
 	m_font = nullptr;
-	fileName = nullptr;
-	tmpBuf = nullptr;
-	fontLoc = nullptr;
 
-	gfxFont = state->getFont();
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+	GfxFont* gfxFont = state->getFont().get();
+#else
+	GfxFont* gfxFont = state->getFont();
+#endif
 	if (!gfxFont)
 		goto err1;
 
@@ -3064,10 +2983,10 @@
 		delete id;
 	else
 	{
-		if (!(fontLoc = gfxFont->locateFont(xref, nullptr)))
+		fontLoc = gfxFont->locateFont((m_xref) ? m_xref : m_pdfDoc->getXRef(), nullptr);
+		if (!fontLoc)
 		{
-			error(errSyntaxError, -1, "Couldn't find a font for '{0:s}'",
-			gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+			error(errSyntaxError, -1, "Couldn't find a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 			goto err2;
 		}
 
@@ -3075,94 +2994,106 @@
 		if (fontLoc->locType == gfxFontLocEmbedded)
 		{
 			// if there is an embedded font, read it to memory
-			tmpBuf = gfxFont->readEmbFontFile(xref, &tmpBufLen);
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+			tmpBuf = gfxFont->readEmbFontFile((m_xref) ? m_xref : m_pdfDoc->getXRef());
 			if (! tmpBuf)
 				goto err2;
+#else
+			tmpBuf = gfxFont->readEmbFontFile(m_xref, &tmpBufLen);
+			if (!tmpBuf)
+				goto err2;
+#endif
 
 			// external font
 		}
 		else
 		{ // gfxFontLocExternal
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 			fileName = fontLoc->path;
+#elif POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+			fileName = fontLoc->pathAsGooString();
+#else
+			fileName = fontLoc->path;
+#endif
 			fontType = fontLoc->fontType;
 		}
 
 		fontsrc = new SplashFontSrc;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+		if (!fileName.empty())
+			fontsrc->setFile(fileName);
+		else
+			fontsrc->setBuf(std::move(tmpBuf.value()));
+#else
 		if (fileName)
-			fontsrc->setFile(fileName, gFalse);
+			fontsrc->setFile(fileName, false);
 		else
-			fontsrc->setBuf(tmpBuf, tmpBufLen, gTrue);
+			fontsrc->setBuf(tmpBuf, tmpBufLen, true);
+#endif
 
 		// load the font file
 		switch (fontType) {
 		case fontType1:
-			if (!(fontFile = m_fontEngine->loadType1Font(
-				id,
-				fontsrc,
-				(const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
+			if (!(fontFile = m_fontEngine->loadType1Font(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
 		case fontType1C:
-			if (!(fontFile = m_fontEngine->loadType1CFont(
-							id,
-							fontsrc,
-							(const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
+			if (!(fontFile = m_fontEngine->loadType1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
 		case fontType1COT:
-			if (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(
-							id,
-							fontsrc,
-							(const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
+			if (!(fontFile = m_fontEngine->loadOpenTypeT1CFont(id, fontsrc, (const char **)((Gfx8BitFont *) gfxFont)->getEncoding())))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
 		case fontTrueType:
 		case fontTrueTypeOT:
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+			if (!fileName.empty())
+				ff = FoFiTrueType::load(fileName.c_str());
+			else
+				ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());
+#else
 			if (fileName)
-				ff = FoFiTrueType::load(fileName->getCString());
+				ff = FoFiTrueType::load(fileName->c_str());
 			else
 				ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
+#endif
 			if (ff)
 			{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+				codeToGID = ((Gfx8BitFont*) gfxFont)->getCodeToGIDMap(ff.get());
+				ff.reset();
+#else
 				codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);
-				n = 256;
 				delete ff;
+#endif
+				n = 256;
 			}
 			else
 			{
 				codeToGID = nullptr;
 				n = 0;
 			}
-			if (!(fontFile = m_fontEngine->loadTrueTypeFont(
-							id,
-							fontsrc,
-							codeToGID, n)))
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
 		case fontCIDType0:
 		case fontCIDType0C:
-			if (!(fontFile = m_fontEngine->loadCIDFont(
-							id,
-							fontsrc)))
+			if (!(fontFile = m_fontEngine->loadCIDFont(id, fontsrc)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
@@ -3178,13 +3109,10 @@
 				codeToGID = nullptr;
 				n = 0;
 			}
-			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(
-							id,
-							fontsrc,
-							codeToGID, n)))
+			if (!(fontFile = m_fontEngine->loadOpenTypeCFFFont(id, fontsrc, codeToGID, n)))
 			{
 				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
@@ -3203,22 +3131,30 @@
 			}
 			else
 			{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
+				if (!fileName.empty())
+					ff = FoFiTrueType::load(fileName.c_str());
+				else
+					ff = FoFiTrueType::make(fontsrc->buf.data(), fontsrc->buf.size());
+#else
 				if (fileName)
-					ff = FoFiTrueType::load(fileName->getCString());
+					ff = FoFiTrueType::load(fileName->c_str());
 				else
 					ff = FoFiTrueType::make(tmpBuf, tmpBufLen);
+#endif
 				if (! ff)
 					goto err2;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 2, 0)
+				codeToGID = ((GfxCIDFont*) gfxFont)->getCodeToGIDMap(ff.get(), &n);
+				ff.reset();
+#else
 				codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);
 				delete ff;
+#endif
 			}
-			if (!(fontFile = m_fontEngine->loadTrueTypeFont(
-							id,
-							fontsrc,
-							codeToGID, n, faceIndex)))
+			if (!(fontFile = m_fontEngine->loadTrueTypeFont(id, fontsrc, codeToGID, n, faceIndex)))
 			{
-				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'",
-				gfxFont->getName() ? gfxFont->getName()->getCString() : "(unnamed)");
+				error(errSyntaxError, -1, "Couldn't create a font for '{0:s}'", gfxFont->getName() ? gfxFont->getName()->c_str() : "(unnamed)");
 				goto err2;
 			}
 			break;
@@ -3247,20 +3183,25 @@
 	mat[3] = -m22;
 	m_font = m_fontEngine->getFont(fontFile, mat, matrix);
 
+#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(22, 2, 0)
 	delete fontLoc;
+#endif
 	if (fontsrc && !fontsrc->isFile)
 		fontsrc->unref();
 	return;
 
 err2:
 	delete id;
+#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(22, 2, 0)
 	delete fontLoc;
+#endif
+
 err1:
 	if (fontsrc && !fontsrc->isFile)
 		fontsrc->unref();
 }
 
-void SlaOutputDev::drawChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, POPPLER_CONST_082 Unicode* u, int uLen)
+void SlaOutputDev::drawChar(GfxState* state, double x, double y, double dx, double dy, double originX, double originY, CharCode code, int nBytes, const Unicode* u, int uLen)
 {
 //	qDebug() << "SlaOutputDev::drawChar code:" << code << "bytes:" << nBytes << "Unicode:" << u << "ulen:" << uLen << "render:" << state->getRender();
 	double x1, y1, x2, y2;
@@ -3292,7 +3233,7 @@
 			qPath.setFillRule(Qt::WindingFill);
 			for (int i = 0; i < fontPath->getLength(); ++i)
 			{
-				Guchar f;
+				unsigned char f;
 				fontPath->getPoint(i, &x1, &y1, &f);
 				if (f & splashPathFirst)
 					qPath.moveTo(x1,y1);
@@ -3303,7 +3244,7 @@
 					fontPath->getPoint(i, &x2, &y2, &f);
 					++i;
 					fontPath->getPoint(i, &x3, &y3, &f);
-					qPath.cubicTo(x1,y1,x2,y2,x3,y3);
+					qPath.cubicTo(x1, y1, x2, y2, x3, y3);
 				}
 				else
 					qPath.lineTo(x1, y1);
@@ -3354,19 +3295,25 @@
 }
 
 
-GBool SlaOutputDev::beginType3Char(GfxState *state, double x, double y, double dx, double dy, CharCode code, POPPLER_CONST_082 Unicode *u, int uLen)
+bool SlaOutputDev::beginType3Char(GfxState *state, double x, double y, double dx, double dy, CharCode code, const Unicode *u, int uLen)
 {
 //	qDebug() << "beginType3Char";
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 4, 0)
 	GfxFont *gfxFont;
+	if (!(gfxFont = state->getFont().get()))
+		return true;
+#else
+	GfxFont* gfxFont;
 	if (!(gfxFont = state->getFont()))
-		return gTrue;
+		return true;
+#endif
 	if (gfxFont->getType() != fontType3)
-		return gTrue;
+		return true;
 	F3Entry f3e;
 	f3e.colored = false;
 	m_F3Stack.push(f3e);
 	pushGroup();
-	return gFalse;
+	return false;
 }
 
 void SlaOutputDev::endType3Char(GfxState *state)
@@ -3390,8 +3337,9 @@
 			ite = m_doc->m_Selection->itemAt(0);
 		if (!f3e.colored)
 		{
-			m_doc->itemSelection_SetItemBrush(m_currColorFill);
-			m_doc->itemSelection_SetItemBrushShade(m_currFillShade);
+			const auto& graphicState = m_graphicStack.top();
+			m_doc->itemSelection_SetItemBrush(graphicState.fillColor);
+			m_doc->itemSelection_SetItemBrushShade(graphicState.fillShade);
 			m_doc->itemSelection_SetItemFillTransparency(1.0 - state->getFillOpacity());
 			m_doc->itemSelection_SetItemFillBlend(getBlendMode(state));
 		}
@@ -3425,47 +3373,47 @@
 //	qDebug() << "SlaOutputDev::endTextObject";
 	if (!m_clipTextPath.isEmpty())
 	{
-		m_currentClipPath = intersection(m_currentClipPath, m_clipTextPath);
+		m_graphicStack.top().clipPath = intersection(m_graphicStack.top().clipPath, m_clipTextPath);
 		m_clipTextPath = QPainterPath();
 	}
 	if (m_groupStack.count() != 0)
 	{
 		groupEntry gElements = m_groupStack.pop();
-		tmpSel->clear();
+		m_tmpSel->clear();
 		if (gElements.Items.count() > 0)
 		{
 			for (int dre = 0; dre < gElements.Items.count(); ++dre)
 			{
-				tmpSel->addItem(gElements.Items.at(dre), true);
+				m_tmpSel->addItem(gElements.Items.at(dre), true);
 				m_Elements->removeAll(gElements.Items.at(dre));
 			}
 			PageItem *ite;
 			if (gElements.Items.count() != 1)
-				ite = m_doc->groupObjectsSelection(tmpSel);
+				ite = m_doc->groupObjectsSelection(m_tmpSel);
 			else
 				ite = gElements.Items.first();
 			ite->setGroupClipping(false);
 			ite->setFillTransparency(1.0 - state->getFillOpacity());
 			ite->setFillBlendmode(getBlendMode(state));
-			for (int as = 0; as < tmpSel->count(); ++as)
+			for (int as = 0; as < m_tmpSel->count(); ++as)
 			{
-				m_Elements->append(tmpSel->itemAt(as));
+				m_Elements->append(m_tmpSel->itemAt(as));
 			}
 			if (m_groupStack.count() != 0)
 				applyMask(ite);
 		}
 		if (m_groupStack.count() != 0)
 		{
-			for (int as = 0; as < tmpSel->count(); ++as)
+			for (int as = 0; as < m_tmpSel->count(); ++as)
 			{
-				m_groupStack.top().Items.append(tmpSel->itemAt(as));
+				m_groupStack.top().Items.append(m_tmpSel->itemAt(as));
 			}
 		}
-		tmpSel->clear();
+		m_tmpSel->clear();
 	}
 }
 
-QString SlaOutputDev::getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade)
+QString SlaOutputDev::getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade)
 {
 	QString fNam;
 	QString namPrefix = "FromPDF";
@@ -3512,7 +3460,7 @@
 	{
 		GfxSeparationColorSpace* sepColorSpace = (GfxSeparationColorSpace*) color_space;
 		GfxColorSpace* altColorSpace = sepColorSpace->getAlt();
-		QString name = QString(sepColorSpace->getName()->getCString());
+		QString name = QString(sepColorSpace->getName()->c_str());
 		bool isRegistrationColor = (name == "All");
 		if (isRegistrationColor)
 		{
@@ -3612,18 +3560,18 @@
 	return fNam;
 }
 
-QString SlaOutputDev::convertPath(POPPLER_CONST_083 GfxPath *path)
+QString SlaOutputDev::convertPath(const GfxPath *path)
 {
 //	qDebug() << "SlaOutputDev::convertPath";
 	if (! path)
 		return QString();
 
 	QString output;
-	pathIsClosed = false;
+	m_pathIsClosed = false;
 
 	for (int i = 0; i < path->getNumSubpaths(); ++i)
 	{
-		POPPLER_CONST_083 GfxSubpath * subpath = path->getSubpath(i);
+		const GfxSubpath * subpath = path->getSubpath(i);
 		if (subpath->getNumPoints() > 0)
 		{
 			output += QString("M %1 %2").arg(subpath->getX(0)).arg(subpath->getY(0));
@@ -3647,7 +3595,7 @@
 			if (subpath->isClosed())
 			{
 				output += QString("Z");
-				pathIsClosed = true;
+				m_pathIsClosed = true;
 			}
 		}
 	}
@@ -3680,16 +3628,21 @@
 			m_lineJoin = Qt::BevelJoin;
 			break;
 	}
-	double lw = state->getLineWidth();
-	double *dashPattern;
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(22, 9, 0)
+	const auto& dashPattern = state->getLineDash(&m_dashOffset);
+	QVector<double> pattern(dashPattern.size());
+	for (size_t i = 0; i < dashPattern.size(); ++i)
+		pattern[i] = dashPattern[i];
+	m_dashValues = pattern;
+#else
+	double* dashPattern;
 	int dashLength;
-	state->getLineDash(&dashPattern, &dashLength, &DashOffset);
+	state->getLineDash(&dashPattern, &dashLength, &m_dashOffset);
 	QVector<double> pattern(dashLength);
 	for (int i = 0; i < dashLength; ++i)
-	{
-		pattern[i] = dashPattern[i] / lw;
-	}
-	DashValues = pattern;
+		pattern[i] = dashPattern[i];
+	m_dashValues = pattern;
+#endif
 }
 
 int SlaOutputDev::getBlendMode(GfxState *state)
@@ -3779,15 +3732,15 @@
 	}
 	// Code for updating our Progressbar, needs to be called this way, as we have no
 	// possibility to get the current fileposition.
-	updateGUICounter++;
-	if (updateGUICounter > 20)
+	m_updateGUICounter++;
+	if (m_updateGUICounter > 20)
 	{
 		qApp->processEvents();
-		updateGUICounter = 0;
+		m_updateGUICounter = 0;
 	}
 }
 
-void SlaOutputDev::pushGroup(const QString& maskName, GBool forSoftMask, GBool alpha, bool inverted)
+void SlaOutputDev::pushGroup(const QString& maskName, bool forSoftMask, bool alpha, bool inverted)
 {
 	groupEntry gElements;
 	gElements.forSoftMask = forSoftMask;
@@ -3797,23 +3750,23 @@
 	m_groupStack.push(gElements);
 }
 
-QString SlaOutputDev::UnicodeParsedString(POPPLER_CONST GooString *s1)
+QString SlaOutputDev::UnicodeParsedString(const GooString *s1)
 {
 	if ( !s1 || s1->getLength() == 0 )
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	int i;
 	Unicode u;
 	QString result;
 	if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getLength() > 1 && (s1->getChar(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1->getLength() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1->getLength());
 	}
@@ -3838,19 +3791,19 @@
 {
 	if (s1.length() == 0)
 		return QString();
-	GBool isUnicode;
+	bool isUnicode;
 	size_t i;
 	Unicode u;
 	QString result;
 	if ((s1.at(0) & 0xff) == 0xfe && (s1.length() > 1 && (s1.at(1) & 0xff) == 0xff))
 	{
-		isUnicode = gTrue;
+		isUnicode = true;
 		i = 2;
 		result.reserve((s1.length() - 2) / 2);
 	}
 	else
 	{
-		isUnicode = gFalse;
+		isUnicode = false;
 		i = 0;
 		result.reserve(s1.length());
 	}
@@ -3877,9 +3830,10 @@
 bool SlaOutputDev::checkClip()
 {
 	bool ret = false;
-	if (!m_currentClipPath.isEmpty())
+	const auto& graphicState = m_graphicStack.top();
+	if (!graphicState.clipPath.isEmpty())
 	{
-		QRectF bbox = m_currentClipPath.boundingRect();
+		QRectF bbox = graphicState.clipPath.boundingRect();
 		if ((bbox.width() > 0) && (bbox.height() > 0))
 			ret = true;
 	}
@@ -3900,10 +3854,12 @@
 	if (textRenderingMode == 3)
 		return;
 
+	auto& graphicState = m_graphicStack.top();
+
 	// Fill text rendering modes. See above
 	if (textRenderingMode == 0 || textRenderingMode == 2 || textRenderingMode == 4 || textRenderingMode == 6)
 	{
-		m_currColorFill = getColor(state->getFillColorSpace(), state->getFillColor(), &m_currFillShade);
+		graphicState.fillColor = getColor(state->getFillColorSpace(), state->getFillColor(), &graphicState.fillShade);
 		if (textNode->isTextFrame())
 		{
 			textNode->setFillTransparency(1.0 - (state->getFillOpacity() > state->getStrokeOpacity() ? state->getFillOpacity() : state->getStrokeOpacity())); //fill colour sets the background colour for the frame not the fill colour fore  the text
@@ -3911,12 +3867,12 @@
 			textNode->setFillColor(CommonStrings::None);
 			textNode->setLineColor(CommonStrings::None);
 			textNode->setLineWidth(0);//line  width doesn't effect drawing text, it creates a bounding box state->getTransformedLineWidth());
-			textNode->setFillShade(m_currFillShade);
+			textNode->setFillShade(graphicState.fillShade);
 		}
 		else
 		{
-			textNode->setFillColor(m_currColorFill);
-			textNode->setFillShade(m_currFillShade);
+			textNode->setFillColor(graphicState.fillColor);
+			textNode->setFillShade(graphicState.fillShade);
 			textNode->setFillEvenOdd(false);
 			textNode->setFillTransparency(1.0 - state->getFillOpacity());
 			textNode->setFillBlendmode(getBlendMode(state));
@@ -3925,7 +3881,7 @@
 	// Stroke text rendering modes. See above
 	if (textRenderingMode == 1 || textRenderingMode == 2 || textRenderingMode == 5 || textRenderingMode == 6)
 	{
-		m_currColorStroke = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &m_currStrokeShade);
+		graphicState.strokeColor = getColor(state->getStrokeColorSpace(), state->getStrokeColor(), &graphicState.strokeShade);
 		if (textNode->isTextFrame())
 		{
 			//fill color sets the background color for the frame not the fill color fore  the text
@@ -3935,16 +3891,16 @@
 			textNode->setLineColor(CommonStrings::None);
 			textNode->setLineWidth(0);//line  width doesn't effect drawing text, it creates a bounding box state->getTransformedLineWidth());
 			textNode->setFillBlendmode(getBlendMode(state));
-			textNode->setFillShade(m_currFillShade);
+			textNode->setFillShade(graphicState.fillShade);
 		}
 		else
 		{
-			textNode->setLineColor(m_currColorStroke);
+			textNode->setLineColor(graphicState.strokeColor);
 			textNode->setLineWidth(0);//line  width doesn't effect drawing text, it creates a bounding box state->getTransformedLineWidth());
 			textNode->setFillTransparency(1.0 - state->getFillOpacity() > state->getStrokeOpacity() ? state->getFillOpacity() : state->getStrokeOpacity());
 			textNode->setLineTransparency(1.0); // this sets the transparency of the textbox border and we don't want to see it
 			textNode->setLineBlendmode(getBlendMode(state));
-			textNode->setLineShade(m_currStrokeShade);
+			textNode->setLineShade(graphicState.strokeShade);
 		}
 	}
 }
diff -Naur a/scribus/plugins/import/pdf/slaoutput.h b/scribus/plugins/import/pdf/slaoutput.h
--- a/scribus/plugins/import/pdf/slaoutput.h	2022-01-23 17:16:01.000000000 +0100
+++ b/scribus/plugins/import/pdf/slaoutput.h	2022-10-06 13:58:35.965648052 +0200
@@ -30,9 +30,6 @@
 #include "selection.h"
 #include "vgradient.h"
 
-#if POPPLER_ENCODED_VERSION < POPPLER_VERSION_ENCODE(0, 73, 0)
-#include <poppler/goo/gtypes.h>
-#endif
 #include <poppler/Object.h>
 #include <poppler/OutputDev.h>
 #include <poppler/Gfx.h>
@@ -68,9 +65,9 @@
 	virtual ~LinkSubmitForm();
 
 	// Was the LinkImportData created successfully?
-	GBool isOk() POPPLER_CONST override { return fileName != nullptr; }
+	bool isOk() const override { return fileName != nullptr; }
 	// Accessors.
-	LinkActionKind getKind() POPPLER_CONST override { return actionUnknown; }
+	LinkActionKind getKind() const override { return actionUnknown; }
 	GooString *getFileName() { return fileName; }
 	int getFlags() { return m_flags; }
 
@@ -92,9 +89,9 @@
 	virtual ~LinkImportData();
 
 	// Was the LinkImportData created successfully?
-	GBool isOk() POPPLER_CONST override { return fileName != nullptr; }
+	bool isOk() const override { return fileName != nullptr; }
 	// Accessors.
-	LinkActionKind getKind() POPPLER_CONST override { return actionUnknown; }
+	LinkActionKind getKind() const override { return actionUnknown; }
 	GooString *getFileName() { return fileName; }
 
 private:
@@ -111,7 +108,7 @@
 	SlaOutFontFileID(const Ref *rA) { r = *rA; }
 	~SlaOutFontFileID() {}
 
-	GBool matches(SplashFontFileID *id) override
+	bool matches(SplashFontFileID *id) override
 	{
 		return ((SlaOutFontFileID*) id)->r.num == r.num && ((SlaOutFontFileID *) id)->r.gen == r.gen;
 	}
@@ -127,19 +124,19 @@
 	AnoOutputDev(ScribusDoc* doc, QStringList *importedColors);
 	virtual ~AnoOutputDev();
 
-	GBool isOk() { return gTrue; }
-	GBool upsideDown() override { return gTrue; }
-	GBool useDrawChar() override { return gFalse; }
-	GBool interpretType3Chars() override { return gFalse; }
-	GBool useTilingPatternFill() override  { return gFalse; }
-	GBool useShadedFills(int type) override { return gFalse; }
-	GBool useFillColorStop() override { return gFalse; }
-	GBool useDrawForm() override { return gFalse; }
+	bool isOk() { return true; }
+	bool upsideDown() override { return true; }
+	bool useDrawChar() override { return false; }
+	bool interpretType3Chars() override { return false; }
+	bool useTilingPatternFill() override  { return false; }
+	bool useShadedFills(int type) override { return false; }
+	bool useFillColorStop() override { return false; }
+	bool useDrawForm() override { return false; }
 
 	void stroke(GfxState *state) override;
 	void eoFill(GfxState *state) override;
 	void fill(GfxState *state) override;
-	void drawString(GfxState *state, POPPLER_CONST GooString *s) override;
+	void drawString(GfxState *state, const GooString *s) override;
 
 	QString currColorText;
 	QString currColorFill;
@@ -149,7 +146,7 @@
 	GooString *itemText {nullptr};
 
 private:
-	QString getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade);
+	QString getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade);
 	ScribusDoc* m_doc;
 	QStringList *m_importedColors;
 };
@@ -163,12 +160,8 @@
 	virtual ~SlaOutputDev();
 
 	LinkAction* SC_getAction(AnnotWidget *ano);
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(0, 86, 0)
 	std::unique_ptr<LinkAction> SC_getAdditionalAction(const char *key, AnnotWidget *ano);
-#else
-	LinkAction* SC_getAdditionalAction(const char *key, AnnotWidget *ano);
-#endif
-	static GBool annotations_callback(Annot *annota, void *user_data);
+	static bool annotations_callback(Annot *annota, void *user_data);
 	bool handleTextAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
 	bool handleLinkAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
 	bool handleWidgetAnnot(Annot* annota, double xCoor, double yCoor, double width, double height);
@@ -176,16 +169,16 @@
 	void handleActions(PageItem* ite, AnnotWidget *ano);
 	void startDoc(PDFDoc *doc, XRef *xrefA, Catalog *catA);
 
-	GBool isOk() { return gTrue; }
-	GBool upsideDown() override { return gTrue; }
-	GBool useDrawChar() override { return gTrue; }
-	GBool interpretType3Chars() override { return gTrue; }
-	GBool useTilingPatternFill() override { return gTrue; }
-	GBool useShadedFills(int type) override { return type <= 7; }
-	GBool useFillColorStop() override { return gTrue; }
-	GBool useDrawForm() override { return gFalse; }
+	bool isOk() { return true; }
+	bool upsideDown() override { return true; }
+	bool useDrawChar() override { return true; }
+	bool interpretType3Chars() override { return true; }
+	bool useTilingPatternFill() override { return true; }
+	bool useShadedFills(int type) override { return type <= 7; }
+	bool useFillColorStop() override { return true; }
+	bool useDrawForm() override { return false; }
 
-//	virtual GBool needClipToCropBox() { return gTrue; }
+//	virtual bool needClipToCropBox() { return true; }
 	void startPage(int pageNum, GfxState *, XRef *) override;
 	void endPage() override;
 
@@ -197,35 +190,31 @@
 	void stroke(GfxState *state) override;
 	void fill(GfxState *state) override;
 	void eoFill(GfxState *state) override;
-#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 3, 0)
 	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
-#else
-	GBool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, Object *str, POPPLER_CONST_070 double *pmat, int paintType, int tilingType, Dict *resDict, POPPLER_CONST_070 double *mat, POPPLER_CONST_070 double *bbox, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
-#endif
-	GBool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return gFalse; }
-	GBool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
-	GBool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
-	GBool radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax) override;
-	GBool radialShadedSupportExtend(GfxState *state, GfxRadialShading *shading) override { return (shading->getExtend0() == shading->getExtend1()); }
-	GBool gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading) override;
-	GBool patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading) override;
+	bool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return false; }
+	bool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
+	bool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
+	bool radialShadedFill(GfxState *state, GfxRadialShading *shading, double sMin, double sMax) override;
+	bool radialShadedSupportExtend(GfxState *state, GfxRadialShading *shading) override { return (shading->getExtend0() == shading->getExtend1()); }
+	bool gouraudTriangleShadedFill(GfxState *state, GfxGouraudTriangleShading *shading) override;
+	bool patchMeshShadedFill(GfxState *state, GfxPatchMeshShading *shading) override;
 
 	//----- path clipping
 	void clip(GfxState *state) override;
 	void eoClip(GfxState *state) override;
 	void clipToStrokePath(GfxState * /*state*/) override { qDebug() << "Clip to StrokePath"; }
-	virtual GBool deviceHasTextClip(GfxState *state) { return gFalse; }
+	virtual bool deviceHasTextClip(GfxState *state) { return false; }
 
   // If current colorspace is pattern,
   // does this device support text in pattern colorspace?
-	virtual GBool supportTextCSPattern(GfxState *state)
+	virtual bool supportTextCSPattern(GfxState *state)
 	{
 		return state->getFillColorSpace()->getMode() == csPattern;
 	}
 
   // If current colorspace is pattern,
   // need this device special handling for masks in pattern colorspace?
-	virtual GBool fillMaskCSPattern(GfxState * state)
+	virtual bool fillMaskCSPattern(GfxState * state)
 	{
 		return state->getFillColorSpace()->getMode() == csPattern;
 	}
@@ -233,37 +222,37 @@
 	virtual void endMaskClip(GfxState *state) { qDebug() << "End Mask Clip"; }
 
   //----- grouping operators
-	void beginMarkedContent(POPPLER_CONST char *name, Dict *properties) override;
-	virtual void beginMarkedContent(POPPLER_CONST char *name, Object *dictRef);
+	void beginMarkedContent(const char *name, Dict *properties) override;
+	virtual void beginMarkedContent(const char *name, Object *dictRef);
 	void endMarkedContent(GfxState *state) override;
-	void markPoint(POPPLER_CONST char *name) override;
-	void markPoint(POPPLER_CONST char *name, Dict *properties) override;
+	void markPoint(const char *name) override;
+	void markPoint(const char *name, Dict *properties) override;
 
 	//----- image drawing
-	void drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, GBool invert, GBool interpolate, GBool inlineImg) override;
-	void drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, GBool interpolate, POPPLER_CONST_082 int *maskColors, GBool inlineImg) override;
+	void drawImageMask(GfxState *state, Object *ref, Stream *str, int width, int height, bool invert, bool interpolate, bool inlineImg) override;
+	void drawImage(GfxState *state, Object *ref, Stream *str, int width, int height, GfxImageColorMap *colorMap, bool interpolate, const int *maskColors, bool inlineImg) override;
 	void drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,
 				   int width, int height,
 				   GfxImageColorMap *colorMap,
-				   GBool interpolate,
+				   bool interpolate,
 				   Stream *maskStr,
 				   int maskWidth, int maskHeight,
 				   GfxImageColorMap *maskColorMap,
-				   GBool maskInterpolate) override;
+				   bool maskInterpolate) override;
 
 	void drawMaskedImage(GfxState *state, Object *ref, Stream *str,
 				   int width, int height,
 				   GfxImageColorMap *colorMap,
-				   GBool interpolate,
+				   bool interpolate,
 				   Stream *maskStr,
 				   int maskWidth, int maskHeight,
-				   GBool maskInvert, GBool maskInterpolate) override; // { qDebug() << "Draw Masked Image"; }
+				   bool maskInvert, bool maskInterpolate) override; // { qDebug() << "Draw Masked Image"; }
 
 	//----- transparency groups and soft masks
-	void beginTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox, GfxColorSpace * /*blendingColorSpace*/, GBool /*isolated*/, GBool /*knockout*/, GBool /*forSoftMask*/) override;
-	void paintTransparencyGroup(GfxState *state, POPPLER_CONST_070 double *bbox) override;
+	void beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool /*isolated*/, bool /*knockout*/, bool /*forSoftMask*/) override;
+	void paintTransparencyGroup(GfxState *state, const double *bbox) override;
 	void endTransparencyGroup(GfxState *state) override;
-	void setSoftMask(GfxState * /*state*/, POPPLER_CONST_070 double * /*bbox*/, GBool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
+	void setSoftMask(GfxState * /*state*/, const double * /*bbox*/, bool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
 	void clearSoftMask(GfxState * /*state*/) override;
 
 	void updateFillColor(GfxState *state) override;
@@ -273,8 +262,8 @@
 	//----- text drawing
 	void  beginTextObject(GfxState *state) override;
 	void  endTextObject(GfxState *state) override;
-	void  drawChar(GfxState *state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, POPPLER_CONST_082 Unicode * /*u*/, int /*uLen*/) override;
-	GBool beginType3Char(GfxState * /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, POPPLER_CONST_082 Unicode * /*u*/, int /*uLen*/) override;
+	void  drawChar(GfxState *state, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, double /*originX*/, double /*originY*/, CharCode /*code*/, int /*nBytes*/, const Unicode * /*u*/, int /*uLen*/) override;
+	bool  beginType3Char(GfxState * /*state*/, double /*x*/, double /*y*/, double /*dx*/, double /*dy*/, CharCode /*code*/, const Unicode * /*u*/, int /*uLen*/) override;
 	void  endType3Char(GfxState * /*state*/) override;
 	void  type3D0(GfxState * /*state*/, double /*wx*/, double /*wy*/) override;
 	void  type3D1(GfxState * /*state*/, double /*wx*/, double /*wy*/, double /*llx*/, double /*lly*/, double /*urx*/, double /*ury*/) override;
@@ -293,37 +282,85 @@
 protected:
 	void setItemFillAndStroke(GfxState* state, PageItem* textNode);
 	void applyMask(PageItem* ite);
-	void pushGroup(const QString& maskName = "", GBool forSoftMask = gFalse, GBool alpha = gFalse, bool inverted = false);
+	void pushGroup(const QString& maskName = "", bool forSoftMask = false, bool alpha = false, bool inverted = false);
 
 	ScribusDoc* m_doc;
 	Qt::PenCapStyle m_lineEnd { Qt::FlatCap };
 	Qt::PenJoinStyle m_lineJoin { Qt::MiterJoin };
 	QList<PageItem*>* m_Elements;
 
+	class GraphicState
+	{
+	public:
+		QString fillColor { "Black" };
+		int     fillShade { 100 };
+		QString strokeColor { "Black "};
+		int     strokeShade { 100 };
+
+		// The currently visible area. If it is empty, everything is visible.
+		// QPainterPath has the drawback that it sometimes approximates Bezier curves
+		// by line segments for numerical stability. If available, a better class
+		// should be used. However, it is important that the used class knows which
+		// areas are covered and does not rely on external information about the fill
+		// rule to use.
+		QPainterPath clipPath;
+	};
+
+	class GraphicStack
+	{
+	public:
+		GraphicStack()
+		{
+			m_stack.push(GraphicState());
+		}
+
+		void clear()
+		{
+			m_stack.clear();
+			m_stack.push(GraphicState());
+		}
+
+		void save()
+		{
+			m_stack.push(m_stack.top());
+		}
+
+		void restore()
+		{
+			if (m_stack.count() > 0)
+				m_stack.pop();
+			if (m_stack.count() == 0)
+				m_stack.push(GraphicState());
+		}
+
+		GraphicState& top() { return m_stack.top(); }
+		const GraphicState& top() const  { return m_stack.top(); }
+
+	private:
+		QStack<GraphicState> m_stack;
+	};
+
 	struct groupEntry
 	{
 		QList<PageItem*> Items;
-		GBool forSoftMask { gFalse };
-		GBool isolated { gFalse };
-		GBool alpha { gFalse };
+		bool forSoftMask { false };
+		bool isolated { false };
+		bool alpha { false };
 		QString maskName;
 		QPointF maskPos;
 		bool inverted { false };
 	};
 
 	QStack<groupEntry> m_groupStack;
-	QString m_currColorFill;
-	QString m_currColorStroke;
-	int m_currFillShade { 100 };
-	int m_currStrokeShade { 100 };
+	GraphicStack m_graphicStack;
 
 private:
 	void getPenState(GfxState *state);
-	QString getColor(GfxColorSpace *color_space, POPPLER_CONST_070 GfxColor *color, int *shade);
+	QString getColor(GfxColorSpace *color_space, const GfxColor *color, int *shade);
 	QString getAnnotationColor(const AnnotColor *color);
-	QString convertPath(POPPLER_CONST_083 GfxPath *path);
+	QString convertPath(const GfxPath *path);
 	int getBlendMode(GfxState *state);
-	QString UnicodeParsedString(POPPLER_CONST GooString *s1);
+	QString UnicodeParsedString(const GooString *s1);
 	QString UnicodeParsedString(const std::string& s1);
 	bool checkClip();
 
@@ -337,24 +374,17 @@
 
 	void createImageFrame(QImage& image, GfxState *state, int numColorComponents);
 
-	bool pathIsClosed { false };
-	QVector<double> DashValues;
-	double DashOffset { 0.0 };
-	QString Coords;
-	// The currently visible area. If it is empty, everything is visible.
-	// QPainterPath has the drawback that it sometimes approximates Bezier curves
-	// by line segments for numerical stability. If available, a better class
-	// should be used. However, it is important that the used class knows which
-	// areas are covered and does not rely on external information about the fill
-	// rule to use.
-	QPainterPath m_currentClipPath;
-	QStack<QPainterPath> m_clipPaths;
+	bool m_pathIsClosed { false };
+	QVector<double> m_dashValues;
+	double m_dashOffset { 0.0 };
+	QString m_coords;
+
 	// Collect the paths of character glyphs for clipping of a whole text group.
 	QPainterPath  m_clipTextPath;
 
 	QString m_currentMask;
 	QPointF m_currentMaskPosition;
-	Selection* tmpSel { nullptr };
+	Selection* m_tmpSel { nullptr };
 	QStringList *m_importedColors;
 	QTransform m_ctm;
 	struct F3Entry
@@ -368,15 +398,15 @@
 		QString ocgName;
 	};
 	QStack<mContent> m_mcStack;
-	int inPattern {0};
-	int layerNum {1};
-	int currentLayer { 0 };
-	bool firstLayer {true};
-	int importerFlags;
-	int updateGUICounter {0};
-	XRef *xref {nullptr};		// xref table for current document
-	PDFDoc *pdfDoc {nullptr};
-	Catalog *catalog {nullptr};
+	int m_inPattern {0};
+	int m_layerNum {1};
+	int m_currentLayer { 0 };
+	bool m_firstLayer {true};
+	int m_importerFlags;
+	int m_updateGUICounter {0};
+	XRef *m_xref {nullptr};		// xref table for current document
+	PDFDoc *m_pdfDoc {nullptr};
+	Catalog *m_catalog {nullptr};
 	SplashFontEngine *m_fontEngine {nullptr};
 	SplashFont *m_font {nullptr};
 #if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(21, 4, 0)
